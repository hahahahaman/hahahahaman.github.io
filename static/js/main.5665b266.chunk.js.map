{"version":3,"sources":["redux/actionTypes.jsx","components/AboutPage/AboutPage.module.css","components/ResponsiveIframe/ResponsiveIframe.jsx","components/ResponsiveIframe/ResponsiveIframe.module.css","App.js","components/AboutPage/AboutPage.jsx","components/react-grid-layout/components/WidthProvider.jsx","components/react-grid-layout/utils.js","components/react-grid-layout/responsiveUtils.js","components/react-grid-layout/GridItem.jsx","redux/actions.jsx","components/react-grid-layout/ReactGridLayout.jsx","components/react-grid-layout/ResponsiveReactGridLayout.jsx","components/IframeGridLayout/IframeGridLayout.jsx","redux/reducers/index.jsx","redux/store.jsx","serviceWorker.js","index.js"],"names":["__webpack_require__","d","__webpack_exports__","DRAG_START","DRAG_END","RESIZE_START","RESIZE_END","module","exports","about","side-margins","test","ResponsiveIframe","state","is_resizing","is_dragging","react__WEBPACK_IMPORTED_MODULE_5___default","a","createElement","className","styles","iframe","style","pointer-events","this","props","title","src","allowFullScreen","Component","connect","iframe-container","ResponsiveReactGridLayout","WidthProvider","IframeGridLayout","originalLayouts","key","ls","global","localStorage","JSON","parse","getItem","e","getFromLS","ResponsiveLocalStorageLayout","_this","Object","_home_docs_code_projects_hahahahaman_github_io_node_modules_babel_runtime_helpers_esm_classCallCheck__WEBPACK_IMPORTED_MODULE_1__","_home_docs_code_projects_hahahahaman_github_io_node_modules_babel_runtime_helpers_esm_possibleConstructorReturn__WEBPACK_IMPORTED_MODULE_3__","_home_docs_code_projects_hahahahaman_github_io_node_modules_babel_runtime_helpers_esm_getPrototypeOf__WEBPACK_IMPORTED_MODULE_4__","call","layouts","stringify","setState","layout","value","setItem","_home_docs_code_projects_hahahahaman_github_io_node_modules_babel_runtime_helpers_esm_defineProperty__WEBPACK_IMPORTED_MODULE_0__","_this2","react__WEBPACK_IMPORTED_MODULE_6___default","onClick","resetLayout","console","log","cols","lg","md","sm","xs","xxs","rowHeight","onLayoutChange","data-grid","w","h","x","y","minW","minH","_components_ResponsiveIframe_ResponsiveIframe_jsx__WEBPACK_IMPORTED_MODULE_10__","xss","React","PureComponent","Test","PDF_Page","PG","href","App","react_router_dom__WEBPACK_IMPORTED_MODULE_7__","react_router_dom__WEBPACK_IMPORTED_MODULE_8__","exact","path","component","AboutPage","_Component","_home_docs_code_projects_hahahahaman_github_io_node_modules_babel_runtime_helpers_esm_classCallCheck__WEBPACK_IMPORTED_MODULE_0__","_home_docs_code_projects_hahahahaman_github_io_node_modules_babel_runtime_helpers_esm_possibleConstructorReturn__WEBPACK_IMPORTED_MODULE_2__","_home_docs_code_projects_hahahahaman_github_io_node_modules_babel_runtime_helpers_esm_getPrototypeOf__WEBPACK_IMPORTED_MODULE_3__","apply","arguments","_home_docs_code_projects_hahahahaman_github_io_node_modules_babel_runtime_helpers_esm_inherits__WEBPACK_IMPORTED_MODULE_4__","_home_docs_code_projects_hahahahaman_github_io_node_modules_babel_runtime_helpers_esm_createClass__WEBPACK_IMPORTED_MODULE_1__","ComposedComponent","_class","_temp","_React$Component","_getPrototypeOf2","_len","length","args","Array","_key","concat","width","mounted","onWindowResize","node","ReactDOM","findDOMNode","_home_docs_code_projects_hahahahaman_github_io_node_modules_babel_runtime_helpers_esm_assertThisInitialized__WEBPACK_IMPORTED_MODULE_5__","HTMLElement","offsetWidth","_home_docs_code_projects_hahahahaman_github_io_node_modules_babel_runtime_helpers_esm_inherits__WEBPACK_IMPORTED_MODULE_6__","_home_docs_code_projects_hahahahaman_github_io_node_modules_babel_runtime_helpers_esm_createClass__WEBPACK_IMPORTED_MODULE_2__","window","addEventListener","removeEventListener","_this$props","measureBeforeMount","rest","_home_docs_code_projects_hahahahaman_github_io_node_modules_babel_runtime_helpers_esm_objectWithoutProperties__WEBPACK_IMPORTED_MODULE_0__","react__WEBPACK_IMPORTED_MODULE_7___default","assign","defaultProps","isProduction","process","DEBUG","bottom","bottomY","max","i","len","cloneLayout","newLayout","cloneLayoutItem","layoutItem","maxW","maxH","moved","Boolean","static","isDraggable","isResizable","collides","l1","l2","compact","compactType","compareWith","getStatics","sorted","sortLayoutItems","out","l","compactItem","push","indexOf","heightWidth","resolveCompactionCollision","item","moveToCoord","axis","sizeProp","map","otherItem","fullLayout","compactH","Math","min","getFirstCollision","correctBounds","bounds","collidesWith","getLayoutItem","id","getAllCollisions","filter","moveElement","isUserAction","preventCollision","String","oldX","oldY","reverse","collisions","collision","moveElementAwayFromCollision","itemToMove","compactV","fakeItem","undefined","perc","num","sort","b","sortLayoutItemsByColRow","sortLayoutItemsByRowCol","synchronizeLayoutWithChildren","initialLayout","children","Children","forEach","child","exists","_grid","warn","g","contextName","subProps","isArray","Error","j","validateLayout","_objectSpread","_console","noop","getBreakpointFromWidth","breakpoints","sortBreakpoints","matching","breakpointName","getColsFromBreakpoint","breakpoint","findOrGenerateResponsiveLayout","lastBreakpoint","breakpointsSorted","breakpointsAbove","slice","keys","GridItem","resizing","dragging","onDragStart","_ref","dragStart","newPosition","top","left","offsetParent","parentRect","getBoundingClientRect","clientRect","cLeft","transformScale","pLeft","cTop","pTop","scrollLeft","scrollTop","_this$calcXY","calcXY","assertThisInitialized","onDrag","_ref2","deltaX","deltaY","_this$calcXY2","onDragStop","_ref3","dragEnd","_this$calcXY3","onResizeStop","callbackData","resizeEnd","onResizeHandler","onResizeStart","resizeStart","onResize","prevProps","droppingPosition","moveDroppingItem","currentNode","shouldDrag","margin","containerPadding","containerWidth","_this$props2","colWidth","calcColWidth","round","Infinity","height","_this$props3","maxRows","_ref4","_this$props4","pos","_this$props5","usePercentages","useCSSTransforms","translate","transform","WebkitTransform","MozTransform","msTransform","OTransform","position","setTransform","setTopLeft","react_default","react_draggable_min","onStart","onStop","handle","cancel","_this$props6","maxWidth","calcPosition","mins","maxes","minConstraints","maxConstraints","react_resizable","handlerName","_ref5","size","handler","_this$props7","_this$calcWH","calcWH","_this$props8","only","newChild","cloneElement","classNames","react-draggable","react-draggable-dragging","dropping","cssTransforms","GridItem_objectSpread","createStyle","mixinResizable","mixinDraggable","type","verticalCompact","ReactGridLayout","context","el","classCallCheck","possibleConstructorReturn","getPrototypeOf","activeDrag","oldDragItem","oldLayout","oldResizeItem","droppingDOMNode","onDragOver","droppingItem","_e$nativeEvent","nativeEvent","layerX","layerY","toConsumableArray","ReactGridLayout_objectSpread","stopPropagation","preventDefault","onDrop","find","bind","onLayoutMaybeChanged","prevState","autoSize","nbRow","containerPaddingY","placeholder","isEqual","_ref6","_ref7","_this$state","hasCollisions","leastX","leastY","Number","isFinite","_ref8","_this$state2","react_grid_layout_GridItem","isDroppingItem","draggableCancel","draggableHandle","_this$state3","draggable","resizable","isDroppable","mergedClassName","mergedStyle","containerHeight","processGridItem","nextProps","newLayoutBase","propsLayout","c","displayName","generateInitialState","ResponsiveReactGridLayout_objectSpread","defineProperty","colNo","onWidthChange","newBreakpoint","newCols","onBreakpointChange","other","objectWithoutProperties","ReactGridLayout_ReactGridLayout","_ResponsiveReactGridL","inherits","createClass","get","prototype","initialState","rootReducer","action","createStore","location","hostname","match","store","dispatch","render","es","document","getElementById","navigator","serviceWorker","ready","then","registration","unregister"],"mappings":"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","file":"static/js/main.5665b266.chunk.js","sourcesContent":["export const DRAG_START = \"DRAG_START\";\nexport const DRAG_END = \"DRAG_END\";\nexport const RESIZE_START = \"RESIZE_START\";\nexport const RESIZE_END = \"RESIZE_END\";\n","// extracted by mini-css-extract-plugin\nmodule.exports = {\"about\":\"AboutPage_about__2Fozc\",\"side-margins\":\"AboutPage_side-margins__14HPd\",\"test\":\"AboutPage_test__8jm2t\"};","import React, {\n    Component\n} from 'react';\nimport styles from './ResponsiveIframe.module.css'\nimport {\n    connect\n} from 'react-redux';\n\nclass ResponsiveIframe extends Component {\n    state = { is_resizing: false, is_dragging: false };\n    /* constructor(props) {\n     *     super(props);\n     * } */\n    render() {\n        return (\n            <div className={styles['iframe-container']}>\n                <iframe className={styles.iframe}\n                        style={{'pointer-events' : (this.props.is_resizing === true ||\n                                                    this.props.is_dragging? 'none' : 'auto' ) }}\n                        title={this.props.title}\n                        src={this.props.src} allowFullScreen>\n                </iframe>\n            </div>\n        );\n    }\n}\n\nfunction mapStateToProps(state) {\n    return {\n        is_dragging: state.is_dragging,\n        is_resizing: state.is_resizing\n    };\n}\n\nexport default connect(mapStateToProps)(ResponsiveIframe);\n","// extracted by mini-css-extract-plugin\nmodule.exports = {\"iframe-container\":\"ResponsiveIframe_iframe-container__24YWQ\"};","import React from 'react';\n/* import logo from './logo.svg'; */\nimport {\n    BrowserRouter as Router,\n    Route,\n    /* Link */\n} from \"react-router-dom\";\n\nimport {\n    AboutPage\n} from './components/AboutPage/AboutPage.jsx'\nimport ResponsiveIframe from './components/ResponsiveIframe/ResponsiveIframe.jsx'\n\nimport WidthProvider from './components/react-grid-layout/components/WidthProvider.jsx'\nimport {\n    IframeGridLayout\n} from \"./components/IframeGridLayout/IframeGridLayout.jsx\"\n\nimport './App.css';\n\nimport {\n    connect\n} from 'react-redux';\n\nimport styles from './components/AboutPage/AboutPage.module.css';\n\n/* const ResponsiveReactGridLayout = WidthProvider(Responsive); */\nconst ResponsiveReactGridLayout = WidthProvider(IframeGridLayout);\nconst originalLayouts = getFromLS(\"layouts\") || {};\n\nclass ResponsiveLocalStorageLayout extends React.PureComponent {\n    constructor(props) {\n        super(props);\n        this.state = {\n            layouts: JSON.parse(JSON.stringify(originalLayouts)),\n            is_dragging: false,\n            is_resizing: false,\n        };\n    }\n\n    static get defaultProps() {\n        return {\n            className: \"layout\",\n            cols: {\n                lg: 12,\n                md: 10,\n                sm: 6,\n                xs: 4,\n                xss: 2\n            },\n            rowHeight: 30\n        };\n    }\n\n    resetLayout() {\n        this.setState({\n            layouts: {}\n        });\n    }\n\n    onLayoutChange(layout, layouts) {\n        saveToLS(\"layouts\", layouts);\n        this.setState({\n            layouts\n        });\n    }\n\n    render() {\n        return (\n            <div>\n                <button onClick=\n                    {() =>\n                    {\n                    this.resetLayout();\n                    console.log('click');\n                    }\n                    }> Reset </button>\n                <ResponsiveReactGridLayout\n                    className=\"layout\"\n                    cols={{ lg: 12, md: 10, sm: 6, xs: 4, xxs: 2}}\n                    rowHeight={30}\n                    layouts={this.state.layouts}\n                    onLayoutChange={(layout, layouts) =>\n                        this.onLayoutChange(layout, layouts)\n                    }\n                >\n                    <div key=\"1\" data-grid={{ w: 6, h: 15, x: 0, y: 0, minW: 2, minH: 3}}>\n                        <ResponsiveIframe title=\"about\" src=\"/test\">\n                            <p>Your browser does not support iframes.</p>\n                        </ResponsiveIframe>\n                    </div>\n                    {/* <div key=\"2\" data-grid={{ w: 3, h: 10, x: 4, y: 0, minW: 2, minH: 3}}>\n                        <ResponsiveIframe title=\"test\" src=\"/test\">\n                        <p>Your browser does not support iframes.</p>\n                        </ResponsiveIframe>\n                        </div> */}\n                    <div key=\"3\" data-grid={{ w: 12, h: 15, x: 0, y: 15, minW: 2, minH: 3}}>\n                        <ResponsiveIframe title=\"engelbart\" src=\"http://dougengelbart.org/\">\n                            <p>Your browser does not support iframes.</p>\n                        </ResponsiveIframe>\n                    </div>\n                    <div key=\"4\" data-grid={{ w: 6, h: 15, x: 6, y: 0, minW: 2, minH: 3}}>\n                        <ResponsiveIframe title=\"PG\" src=\"http://paulgraham.com/articles.html\">\n                            <p>Your browser does not support iframes.</p>\n                        </ResponsiveIframe>\n                    </div>\n                </ResponsiveReactGridLayout>\n            </div>\n        );\n    }\n}\n\n/* module.exports = ResponsiveLocalStorageLayout; */\n\nfunction getFromLS(key) {\n    let ls = {};\n    if (global.localStorage) {\n        try {\n            ls = JSON.parse(global.localStorage.getItem(\"rgl-8\")) || {};\n        } catch (e) {\n            /*Just ignore it*/\n        }\n    }\n    return ls[key];\n}\n\nfunction saveToLS(key, value) {\n    if (global.localStorage) {\n        global.localStorage.setItem(\n            \"rgl-8\",\n            JSON.stringify({\n                [key]: value\n            })\n        );\n    }\n}\n\nfunction Test() {\n    return (\n    <div className={styles.about}>\n        <h2> Test </h2>\n        <p> I don't know how the fuck this shit. </p>\n        <p> I don't know. Is it wrong for me to say I don't know. </p>\n    </div>\n    );\n}\n\nfunction PDF_Page(){\n    return(\n        <div className={styles.about}>\n            <div className={styles['side-margins']}>\n                <h1>PDF</h1>\n                <p>huh</p>\n                <p>ok</p>\n            </div>\n        </div>\n    );\n}\n\nfunction PG(){\n    return(\n        <div className={styles.about}>\n            <div className={styles['side-margins']}>\n                <h1>PDF</h1>\n                <a href='http://paulgraham.com/speak.html'>speak</a>\n            </div>\n        </div>\n    )\n}\n\nfunction App() {\n    return (\n    <Router>\n      <div className=\"App\">\n        <Route exact path=\"/\" component={ResponsiveLocalStorageLayout} />\n        <Route path=\"/about\" component={AboutPage} />\n        <Route path=\"/test\" component={Test} />\n        <Route path=\"/pdf_page\" component={PDF_Page} />\n        <Route path=\"/PG\" component={PG} />\n      </div>\n    </Router>\n    );\n}\n\nexport default App;\n","import React, { Component } from 'react';\nimport styles from './AboutPage.module.css';\n\nexport class AboutPage extends Component {\n  render () {\n    console.log(styles);\n    return (\n      <div className={styles.about}>\n        <div className={styles['side-margins']}>\n          <h2> About </h2>\n          <p>\n            I've been reading Augmenting Human Intellect, by Douglas\n            Engelbart. I wonder if there is still room to create tools\n            to improve thought. I suspect there is, since the\n            description of the memex, given by Vannevar Bush, in my\n            mind, still has not been realized. Collaborative trails of\n            thought seem like a tool which the web could support.\n          </p>\n          <a href=\"http://dougengelbart.org/content/view/138\">Augment</a>\n        </div>\n      </div>\n    );\n  }\n}\n\nexport default AboutPage;\n","// @flow\nimport React from \"react\";\nimport PropTypes from \"prop-types\";\nimport ReactDOM from \"react-dom\";\nimport type { ComponentType as ReactComponentType } from \"react\";\n\ntype WPProps = {\n  className?: string,\n  measureBeforeMount: boolean,\n  style?: Object\n};\n\ntype WPState = {\n  width: number\n};\n\n/*\n * A simple HOC that provides facility for listening to container resizes.\n */\nexport default function WidthProvider<\n  Props,\n  ComposedProps: { ...Props, ...WPProps }\n>(\n  ComposedComponent: ReactComponentType<Props>\n): ReactComponentType<ComposedProps> {\n  return class WidthProvider extends React.Component<ComposedProps, WPState> {\n    static defaultProps = {\n      measureBeforeMount: false\n    };\n\n    static propTypes = {\n      // If true, will not render children until mounted. Useful for getting the exact width before\n      // rendering, to prevent any unsightly resizing.\n      measureBeforeMount: PropTypes.bool\n    };\n\n    state = {\n      width: 1280\n    };\n\n    mounted: boolean = false;\n\n    componentDidMount() {\n      this.mounted = true;\n\n      window.addEventListener(\"resize\", this.onWindowResize);\n      // Call to properly set the breakpoint and resize the elements.\n      // Note that if you're doing a full-width element, this can get a little wonky if a scrollbar\n      // appears because of the grid. In that case, fire your own resize event, or set `overflow: scroll` on your body.\n      this.onWindowResize();\n    }\n\n    componentWillUnmount() {\n      this.mounted = false;\n      window.removeEventListener(\"resize\", this.onWindowResize);\n    }\n\n    onWindowResize = () => {\n      if (!this.mounted) return;\n      // eslint-disable-next-line react/no-find-dom-node\n      const node = ReactDOM.findDOMNode(this); // Flow casts this to Text | Element\n      if (node instanceof HTMLElement)\n        this.setState({ width: node.offsetWidth });\n    };\n\n    render() {\n      const { measureBeforeMount, ...rest } = this.props;\n      if (measureBeforeMount && !this.mounted) {\n        return (\n          <div className={this.props.className} style={this.props.style} />\n        );\n      }\n\n      return <ComposedComponent {...rest} {...this.state} />;\n    }\n  };\n}\n","// @flow\nimport isEqual from \"lodash.isequal\";\nimport React from \"react\";\nimport type {\n  ChildrenArray as ReactChildrenArray,\n  Element as ReactElement\n} from \"react\";\nexport type LayoutItem = {\n  w: number,\n  h: number,\n  x: number,\n  y: number,\n  i: string,\n  minW?: number,\n  minH?: number,\n  maxW?: number,\n  maxH?: number,\n  moved?: boolean,\n  static?: boolean,\n  isDraggable?: ?boolean,\n  isResizable?: ?boolean\n};\nexport type Layout = Array<LayoutItem>;\nexport type Position = {\n  left: number,\n  top: number,\n  width: number,\n  height: number\n};\nexport type ReactDraggableCallbackData = {\n  node: HTMLElement,\n  x?: number,\n  y?: number,\n  deltaX: number,\n  deltaY: number,\n  lastX?: number,\n  lastY?: number\n};\n\nexport type PartialPosition = { left: number, top: number };\nexport type DroppingPosition = { x: number, y: number, e: Event };\nexport type Size = { width: number, height: number };\nexport type GridDragEvent = {\n  e: Event,\n  node: HTMLElement,\n  newPosition: PartialPosition\n};\nexport type GridResizeEvent = { e: Event, node: HTMLElement, size: Size };\nexport type DragOverEvent = MouseEvent & {\n  nativeEvent: {\n    layerX: number,\n    layerY: number\n  }\n};\n\ntype REl = ReactElement<any>;\nexport type ReactChildren = ReactChildrenArray<REl>;\n\n// All callbacks are of the signature (layout, oldItem, newItem, placeholder, e).\nexport type EventCallback = (\n  Layout,\n  oldItem: ?LayoutItem,\n  newItem: ?LayoutItem,\n  placeholder: ?LayoutItem,\n  Event,\n  ?HTMLElement\n) => void;\nexport type CompactType = ?(\"horizontal\" | \"vertical\");\n\nconst isProduction = process.env.NODE_ENV === \"production\";\nconst DEBUG = false;\n\n/**\n * Return the bottom coordinate of the layout.\n *\n * @param  {Array} layout Layout array.\n * @return {Number}       Bottom coordinate.\n */\nexport function bottom(layout: Layout): number {\n  let max = 0,\n    bottomY;\n  for (let i = 0, len = layout.length; i < len; i++) {\n    bottomY = layout[i].y + layout[i].h;\n    if (bottomY > max) max = bottomY;\n  }\n  return max;\n}\n\nexport function cloneLayout(layout: Layout): Layout {\n  const newLayout = Array(layout.length);\n  for (let i = 0, len = layout.length; i < len; i++) {\n    newLayout[i] = cloneLayoutItem(layout[i]);\n  }\n  return newLayout;\n}\n\n// Fast path to cloning, since this is monomorphic\nexport function cloneLayoutItem(layoutItem: LayoutItem): LayoutItem {\n  return {\n    w: layoutItem.w,\n    h: layoutItem.h,\n    x: layoutItem.x,\n    y: layoutItem.y,\n    i: layoutItem.i,\n    minW: layoutItem.minW,\n    maxW: layoutItem.maxW,\n    minH: layoutItem.minH,\n    maxH: layoutItem.maxH,\n    moved: Boolean(layoutItem.moved),\n    static: Boolean(layoutItem.static),\n    // These can be null\n    isDraggable: layoutItem.isDraggable,\n    isResizable: layoutItem.isResizable\n  };\n}\n\n/**\n * Comparing React `children` is a bit difficult. This is a good way to compare them.\n * This will catch differences in keys, order, and length.\n */\nexport function childrenEqual(a: ReactChildren, b: ReactChildren): boolean {\n  return isEqual(\n    React.Children.map(a, c => c.key),\n    React.Children.map(b, c => c.key)\n  );\n}\n\n/**\n * Given two layoutitems, check if they collide.\n */\nexport function collides(l1: LayoutItem, l2: LayoutItem): boolean {\n  if (l1.i === l2.i) return false; // same element\n  if (l1.x + l1.w <= l2.x) return false; // l1 is left of l2\n  if (l1.x >= l2.x + l2.w) return false; // l1 is right of l2\n  if (l1.y + l1.h <= l2.y) return false; // l1 is above l2\n  if (l1.y >= l2.y + l2.h) return false; // l1 is below l2\n  return true; // boxes overlap\n}\n\n/**\n * Given a layout, compact it. This involves going down each y coordinate and removing gaps\n * between items.\n *\n * @param  {Array} layout Layout.\n * @param  {Boolean} verticalCompact Whether or not to compact the layout\n *   vertically.\n * @return {Array}       Compacted Layout.\n */\nexport function compact(\n  layout: Layout,\n  compactType: CompactType,\n  cols: number\n): Layout {\n  // Statics go in the compareWith array right away so items flow around them.\n  const compareWith = getStatics(layout);\n  // We go through the items by row and column.\n  const sorted = sortLayoutItems(layout, compactType);\n  // Holding for new items.\n  const out = Array(layout.length);\n\n  for (let i = 0, len = sorted.length; i < len; i++) {\n    let l = cloneLayoutItem(sorted[i]);\n\n    // Don't move static elements\n    if (!l.static) {\n      l = compactItem(compareWith, l, compactType, cols, sorted);\n\n      // Add to comparison array. We only collide with items before this one.\n      // Statics are already in this array.\n      compareWith.push(l);\n    }\n\n    // Add to output array to make sure they still come out in the right order.\n    out[layout.indexOf(sorted[i])] = l;\n\n    // Clear moved flag, if it exists.\n    l.moved = false;\n  }\n\n  return out;\n}\n\nconst heightWidth = { x: \"w\", y: \"h\" };\n/**\n * Before moving item down, it will check if the movement will cause collisions and move those items down before.\n */\nfunction resolveCompactionCollision(\n  layout: Layout,\n  item: LayoutItem,\n  moveToCoord: number,\n  axis: \"x\" | \"y\"\n) {\n  const sizeProp = heightWidth[axis];\n  item[axis] += 1;\n  const itemIndex = layout\n    .map(layoutItem => {\n      return layoutItem.i;\n    })\n    .indexOf(item.i);\n\n  // Go through each item we collide with.\n  for (let i = itemIndex + 1; i < layout.length; i++) {\n    const otherItem = layout[i];\n    // Ignore static items\n    if (otherItem.static) continue;\n\n    // Optimization: we can break early if we know we're past this el\n    // We can do this b/c it's a sorted layout\n    if (otherItem.y > item.y + item.h) break;\n\n    if (collides(item, otherItem)) {\n      resolveCompactionCollision(\n        layout,\n        otherItem,\n        moveToCoord + item[sizeProp],\n        axis\n      );\n    }\n  }\n\n  item[axis] = moveToCoord;\n}\n\n/**\n * Compact an item in the layout.\n */\nexport function compactItem(\n  compareWith: Layout,\n  l: LayoutItem,\n  compactType: CompactType,\n  cols: number,\n  fullLayout: Layout\n): LayoutItem {\n  const compactV = compactType === \"vertical\";\n  const compactH = compactType === \"horizontal\";\n  if (compactV) {\n    // Bottom 'y' possible is the bottom of the layout.\n    // This allows you to do nice stuff like specify {y: Infinity}\n    // This is here because the layout must be sorted in order to get the correct bottom `y`.\n    l.y = Math.min(bottom(compareWith), l.y);\n    // Move the element up as far as it can go without colliding.\n    while (l.y > 0 && !getFirstCollision(compareWith, l)) {\n      l.y--;\n    }\n  } else if (compactH) {\n    l.y = Math.min(bottom(compareWith), l.y);\n    // Move the element left as far as it can go without colliding.\n    while (l.x > 0 && !getFirstCollision(compareWith, l)) {\n      l.x--;\n    }\n  }\n\n  // Move it down, and keep moving it down if it's colliding.\n  let collides;\n  while ((collides = getFirstCollision(compareWith, l))) {\n    if (compactH) {\n      resolveCompactionCollision(fullLayout, l, collides.x + collides.w, \"x\");\n    } else {\n      resolveCompactionCollision(fullLayout, l, collides.y + collides.h, \"y\");\n    }\n    // Since we can't grow without bounds horizontally, if we've overflown, let's move it down and try again.\n    if (compactH && l.x + l.w > cols) {\n      l.x = cols - l.w;\n      l.y++;\n    }\n  }\n  return l;\n}\n\n/**\n * Given a layout, make sure all elements fit within its bounds.\n *\n * @param  {Array} layout Layout array.\n * @param  {Number} bounds Number of columns.\n */\nexport function correctBounds(\n  layout: Layout,\n  bounds: { cols: number }\n): Layout {\n  const collidesWith = getStatics(layout);\n  for (let i = 0, len = layout.length; i < len; i++) {\n    const l = layout[i];\n    // Overflows right\n    if (l.x + l.w > bounds.cols) l.x = bounds.cols - l.w;\n    // Overflows left\n    if (l.x < 0) {\n      l.x = 0;\n      l.w = bounds.cols;\n    }\n    if (!l.static) collidesWith.push(l);\n    else {\n      // If this is static and collides with other statics, we must move it down.\n      // We have to do something nicer than just letting them overlap.\n      while (getFirstCollision(collidesWith, l)) {\n        l.y++;\n      }\n    }\n  }\n  return layout;\n}\n\n/**\n * Get a layout item by ID. Used so we can override later on if necessary.\n *\n * @param  {Array}  layout Layout array.\n * @param  {String} id     ID\n * @return {LayoutItem}    Item at ID.\n */\nexport function getLayoutItem(layout: Layout, id: string): ?LayoutItem {\n  for (let i = 0, len = layout.length; i < len; i++) {\n    if (layout[i].i === id) return layout[i];\n  }\n}\n\n/**\n * Returns the first item this layout collides with.\n * It doesn't appear to matter which order we approach this from, although\n * perhaps that is the wrong thing to do.\n *\n * @param  {Object} layoutItem Layout item.\n * @return {Object|undefined}  A colliding layout item, or undefined.\n */\nexport function getFirstCollision(\n  layout: Layout,\n  layoutItem: LayoutItem\n): ?LayoutItem {\n  for (let i = 0, len = layout.length; i < len; i++) {\n    if (collides(layout[i], layoutItem)) return layout[i];\n  }\n}\n\nexport function getAllCollisions(\n  layout: Layout,\n  layoutItem: LayoutItem\n): Array<LayoutItem> {\n  return layout.filter(l => collides(l, layoutItem));\n}\n\n/**\n * Get all static elements.\n * @param  {Array} layout Array of layout objects.\n * @return {Array}        Array of static layout items..\n */\nexport function getStatics(layout: Layout): Array<LayoutItem> {\n  return layout.filter(l => l.static);\n}\n\n/**\n * Move an element. Responsible for doing cascading movements of other elements.\n *\n * @param  {Array}      layout            Full layout to modify.\n * @param  {LayoutItem} l                 element to move.\n * @param  {Number}     [x]               X position in grid units.\n * @param  {Number}     [y]               Y position in grid units.\n */\nexport function moveElement(\n  layout: Layout,\n  l: LayoutItem,\n  x: ?number,\n  y: ?number,\n  isUserAction: ?boolean,\n  preventCollision: ?boolean,\n  compactType: CompactType,\n  cols: number\n): Layout {\n  if (l.static) return layout;\n\n  // Short-circuit if nothing to do.\n  if (l.y === y && l.x === x) return layout;\n\n  log(`Moving element ${l.i} to [${String(x)},${String(y)}] from [${l.x},${l.y}]`);\n  const oldX = l.x;\n  const oldY = l.y;\n\n  // This is quite a bit faster than extending the object\n  if (typeof x === \"number\") l.x = x;\n  if (typeof y === \"number\") l.y = y;\n  l.moved = true;\n\n  // If this collides with anything, move it.\n  // When doing this comparison, we have to sort the items we compare with\n  // to ensure, in the case of multiple collisions, that we're getting the\n  // nearest collision.\n  let sorted = sortLayoutItems(layout, compactType);\n  const movingUp =\n    compactType === \"vertical\" && typeof y === \"number\" ? oldY >= y\n    : compactType === \"horizontal\" && typeof x === \"number\" ? oldX >= x\n    : false;\n  if (movingUp) sorted = sorted.reverse();\n  const collisions = getAllCollisions(sorted, l);\n\n  // There was a collision; abort\n  if (preventCollision && collisions.length) {\n    log(`Collision prevented on ${l.i}, reverting.`);\n    l.x = oldX;\n    l.y = oldY;\n    l.moved = false;\n    return layout;\n  }\n\n  // Move each item that collides away from this element.\n  for (let i = 0, len = collisions.length; i < len; i++) {\n    const collision = collisions[i];\n    log(\n      `Resolving collision between ${l.i} at [${l.x},${l.y}] and ${\n        collision.i\n      } at [${collision.x},${collision.y}]`\n    );\n\n    // Short circuit so we can't infinite loop\n    if (collision.moved) continue;\n\n    // Don't move static items - we have to move *this* element away\n    if (collision.static) {\n      layout = moveElementAwayFromCollision(\n        layout,\n        collision,\n        l,\n        isUserAction,\n        compactType,\n        cols\n      );\n    } else {\n      layout = moveElementAwayFromCollision(\n        layout,\n        l,\n        collision,\n        isUserAction,\n        compactType,\n        cols\n      );\n    }\n  }\n\n  return layout;\n}\n\n/**\n * This is where the magic needs to happen - given a collision, move an element away from the collision.\n * We attempt to move it up if there's room, otherwise it goes below.\n *\n * @param  {Array} layout            Full layout to modify.\n * @param  {LayoutItem} collidesWith Layout item we're colliding with.\n * @param  {LayoutItem} itemToMove   Layout item we're moving.\n */\nexport function moveElementAwayFromCollision(\n  layout: Layout,\n  collidesWith: LayoutItem,\n  itemToMove: LayoutItem,\n  isUserAction: ?boolean,\n  compactType: CompactType,\n  cols: number\n): Layout {\n  const compactH = compactType === \"horizontal\";\n  // Compact vertically if not set to horizontal\n  const compactV = compactType !== \"horizontal\";\n  const preventCollision = false; // we're already colliding\n\n  // If there is enough space above the collision to put this element, move it there.\n  // We only do this on the main collision as this can get funky in cascades and cause\n  // unwanted swapping behavior.\n  if (isUserAction) {\n    // Reset isUserAction flag because we're not in the main collision anymore.\n    isUserAction = false;\n\n    // Make a mock item so we don't modify the item here, only modify in moveElement.\n    const fakeItem: LayoutItem = {\n      x: compactH ? Math.max(collidesWith.x - itemToMove.w, 0) : itemToMove.x,\n      y: compactV ? Math.max(collidesWith.y - itemToMove.h, 0) : itemToMove.y,\n      w: itemToMove.w,\n      h: itemToMove.h,\n      i: \"-1\"\n    };\n\n    // No collision? If so, we can go up there; otherwise, we'll end up moving down as normal\n    if (!getFirstCollision(layout, fakeItem)) {\n      log(\n        `Doing reverse collision on ${itemToMove.i} up to [${fakeItem.x},${\n          fakeItem.y\n        }].`\n      );\n      return moveElement(\n        layout,\n        itemToMove,\n        compactH ? fakeItem.x : undefined,\n        compactV ? fakeItem.y : undefined,\n        isUserAction,\n        preventCollision,\n        compactType,\n        cols\n      );\n    }\n  }\n\n  return moveElement(\n    layout,\n    itemToMove,\n    compactH ? itemToMove.x + 1 : undefined,\n    compactV ? itemToMove.y + 1 : undefined,\n    isUserAction,\n    preventCollision,\n    compactType,\n    cols\n  );\n}\n\n/**\n * Helper to convert a number to a percentage string.\n *\n * @param  {Number} num Any number\n * @return {String}     That number as a percentage.\n */\nexport function perc(num: number): string {\n  return num * 100 + \"%\";\n}\n\nexport function setTransform({ top, left, width, height }: Position): Object {\n  // Replace unitless items with px\n  const translate = `translate(${left}px,${top}px)`;\n  return {\n    transform: translate,\n    WebkitTransform: translate,\n    MozTransform: translate,\n    msTransform: translate,\n    OTransform: translate,\n    width: `${width}px`,\n    height: `${height}px`,\n    position: \"absolute\"\n  };\n}\n\nexport function setTopLeft({ top, left, width, height }: Position): Object {\n  return {\n    top: `${top}px`,\n    left: `${left}px`,\n    width: `${width}px`,\n    height: `${height}px`,\n    position: \"absolute\"\n  };\n}\n\n/**\n * Get layout items sorted from top left to right and down.\n *\n * @return {Array} Array of layout objects.\n * @return {Array}        Layout, sorted static items first.\n */\nexport function sortLayoutItems(\n  layout: Layout,\n  compactType: CompactType\n): Layout {\n  if (compactType === \"horizontal\") return sortLayoutItemsByColRow(layout);\n  else return sortLayoutItemsByRowCol(layout);\n}\n\nexport function sortLayoutItemsByRowCol(layout: Layout): Layout {\n  return [].concat(layout).sort(function(a, b) {\n    if (a.y > b.y || (a.y === b.y && a.x > b.x)) {\n      return 1;\n    } else if (a.y === b.y && a.x === b.x) {\n      // Without this, we can get different sort results in IE vs. Chrome/FF\n      return 0;\n    }\n    return -1;\n  });\n}\n\nexport function sortLayoutItemsByColRow(layout: Layout): Layout {\n  return [].concat(layout).sort(function(a, b) {\n    if (a.x > b.x || (a.x === b.x && a.y > b.y)) {\n      return 1;\n    }\n    return -1;\n  });\n}\n\n/**\n * Generate a layout using the initialLayout and children as a template.\n * Missing entries will be added, extraneous ones will be truncated.\n *\n * @param  {Array}  initialLayout Layout passed in through props.\n * @param  {String} breakpoint    Current responsive breakpoint.\n * @param  {?String} compact      Compaction option.\n * @return {Array}                Working layout.\n */\nexport function synchronizeLayoutWithChildren(\n  initialLayout: Layout,\n  children: ReactChildren,\n  cols: number,\n  compactType: CompactType\n): Layout {\n  initialLayout = initialLayout || [];\n\n  // Generate one layout item per child.\n  let layout: Layout = [];\n  React.Children.forEach(children, (child: ReactElement<any>, i: number) => {\n    // Don't overwrite if it already exists.\n    const exists = getLayoutItem(initialLayout, String(child.key));\n    if (exists) {\n      layout[i] = cloneLayoutItem(exists);\n    } else {\n      if (!isProduction && child.props._grid) {\n        console.warn(\n          \"`_grid` properties on children have been deprecated as of React 15.2. \" + // eslint-disable-line\n            \"Please use `data-grid` or add your properties directly to the `layout`.\"\n        );\n      }\n      const g = child.props[\"data-grid\"] || child.props._grid;\n\n      // Hey, this item has a data-grid property, use it.\n      if (g) {\n        if (!isProduction) {\n          validateLayout([g], \"ReactGridLayout.children\");\n        }\n        layout[i] = cloneLayoutItem({ ...g, i: child.key });\n      } else {\n        // Nothing provided: ensure this is added to the bottom\n        layout[i] = cloneLayoutItem({\n          w: 1,\n          h: 1,\n          x: 0,\n          y: bottom(layout),\n          i: String(child.key)\n        });\n      }\n    }\n  });\n\n  // Correct the layout.\n  layout = correctBounds(layout, { cols: cols });\n  layout = compact(layout, compactType, cols);\n\n  return layout;\n}\n\n/**\n * Validate a layout. Throws errors.\n *\n * @param  {Array}  layout        Array of layout items.\n * @param  {String} [contextName] Context name for errors.\n * @throw  {Error}                Validation error.\n */\nexport function validateLayout(\n  layout: Layout,\n  contextName: string = \"Layout\"\n): void {\n  const subProps = [\"x\", \"y\", \"w\", \"h\"];\n  if (!Array.isArray(layout))\n    throw new Error(contextName + \" must be an array!\");\n  for (let i = 0, len = layout.length; i < len; i++) {\n    const item = layout[i];\n    for (let j = 0; j < subProps.length; j++) {\n      if (typeof item[subProps[j]] !== \"number\") {\n        throw new Error(\n          \"ReactGridLayout: \" +\n            contextName +\n            \"[\" +\n            i +\n            \"].\" +\n            subProps[j] +\n            \" must be a number!\"\n        );\n      }\n    }\n    if (item.i && typeof item.i !== \"string\") {\n      throw new Error(\n        \"ReactGridLayout: \" + contextName + \"[\" + i + \"].i must be a string!\"\n      );\n    }\n    if (item.static !== undefined && typeof item.static !== \"boolean\") {\n      throw new Error(\n        \"ReactGridLayout: \" +\n          contextName +\n          \"[\" +\n          i +\n          \"].static must be a boolean!\"\n      );\n    }\n  }\n}\n\n// Flow can't really figure this out, so we just use Object\nexport function autoBindHandlers(el: Object, fns: Array<string>): void {\n  fns.forEach(key => (el[key] = el[key].bind(el)));\n}\n\nfunction log(...args) {\n  if (!DEBUG) return;\n  // eslint-disable-next-line no-console\n  console.log(...args);\n}\n\nexport const noop = () => {};\n","// @flow\n\nimport { cloneLayout, compact, correctBounds } from \"./utils\";\n\nimport type { CompactType, Layout } from \"./utils\";\n\nexport type ResponsiveLayout = {\n  lg?: Layout,\n  md?: Layout,\n  sm?: Layout,\n  xs?: Layout,\n  xxs?: Layout\n};\n\ntype Breakpoint = string;\n\ntype Breakpoints = {\n  lg?: number,\n  md?: number,\n  sm?: number,\n  xs?: number,\n  xxs?: number\n};\n\n/**\n * Given a width, find the highest breakpoint that matches is valid for it (width > breakpoint).\n *\n * @param  {Object} breakpoints Breakpoints object (e.g. {lg: 1200, md: 960, ...})\n * @param  {Number} width Screen width.\n * @return {String}       Highest breakpoint that is less than width.\n */\nexport function getBreakpointFromWidth(\n  breakpoints: Breakpoints,\n  width: number\n): Breakpoint {\n  const sorted = sortBreakpoints(breakpoints);\n  let matching = sorted[0];\n  for (let i = 1, len = sorted.length; i < len; i++) {\n    const breakpointName = sorted[i];\n    if (width > breakpoints[breakpointName]) matching = breakpointName;\n  }\n  return matching;\n}\n\n/**\n * Given a breakpoint, get the # of cols set for it.\n * @param  {String} breakpoint Breakpoint name.\n * @param  {Object} cols       Map of breakpoints to cols.\n * @return {Number}            Number of cols.\n */\nexport function getColsFromBreakpoint(\n  breakpoint: Breakpoint,\n  cols: Breakpoints\n): number {\n  if (!cols[breakpoint]) {\n    throw new Error(\n      \"ResponsiveReactGridLayout: `cols` entry for breakpoint \" +\n        breakpoint +\n        \" is missing!\"\n    );\n  }\n  return cols[breakpoint];\n}\n\n/**\n * Given existing layouts and a new breakpoint, find or generate a new layout.\n *\n * This finds the layout above the new one and generates from it, if it exists.\n *\n * @param  {Object} layouts     Existing layouts.\n * @param  {Array} breakpoints All breakpoints.\n * @param  {String} breakpoint New breakpoint.\n * @param  {String} breakpoint Last breakpoint (for fallback).\n * @param  {Number} cols       Column count at new breakpoint.\n * @param  {Boolean} verticalCompact Whether or not to compact the layout\n *   vertically.\n * @return {Array}             New layout.\n */\nexport function findOrGenerateResponsiveLayout(\n  layouts: ResponsiveLayout,\n  breakpoints: Breakpoints,\n  breakpoint: Breakpoint,\n  lastBreakpoint: Breakpoint,\n  cols: number,\n  compactType: CompactType\n): Layout {\n  // If it already exists, just return it.\n  if (layouts[breakpoint]) return cloneLayout(layouts[breakpoint]);\n  // Find or generate the next layout\n  let layout = layouts[lastBreakpoint];\n  const breakpointsSorted = sortBreakpoints(breakpoints);\n  const breakpointsAbove = breakpointsSorted.slice(\n    breakpointsSorted.indexOf(breakpoint)\n  );\n  for (let i = 0, len = breakpointsAbove.length; i < len; i++) {\n    const b = breakpointsAbove[i];\n    if (layouts[b]) {\n      layout = layouts[b];\n      break;\n    }\n  }\n  layout = cloneLayout(layout || []); // clone layout so we don't modify existing items\n  return compact(correctBounds(layout, { cols: cols }), compactType, cols);\n}\n\n/**\n * Given breakpoints, return an array of breakpoints sorted by width. This is usually\n * e.g. ['xxs', 'xs', 'sm', ...]\n *\n * @param  {Object} breakpoints Key/value pair of breakpoint names to widths.\n * @return {Array}              Sorted breakpoints.\n */\nexport function sortBreakpoints(breakpoints: Breakpoints): Array<Breakpoint> {\n  const keys: Array<string> = Object.keys(breakpoints);\n  return keys.sort(function(a, b) {\n    return breakpoints[a] - breakpoints[b];\n  });\n}\n","// @flow\nimport React from \"react\";\nimport ReactDOM from \"react-dom\";\nimport PropTypes from \"prop-types\";\nimport {\n    DraggableCore\n} from \"react-draggable\";\nimport {\n    Resizable\n} from \"react-resizable\";\nimport {\n    perc,\n    setTopLeft,\n    setTransform\n} from \"./utils\";\nimport classNames from \"classnames\";\nimport type {\n    Element as ReactElement, Node as ReactNode\n} from \"react\";\n\nimport {\n    connect\n} from 'react-redux';\nimport {\n    dragStart,\n    dragEnd,\n    resizeStart,\n    resizeEnd\n} from '../../redux/actions';\n\nimport type {\n    ReactDraggableCallbackData,\n    GridDragEvent,\n    GridResizeEvent,\n    DroppingPosition,\n    Position\n} from \"./utils\";\n\ntype PartialPosition = {\n    top: number,\n    left: number\n};\ntype GridItemCallback < Data: GridDragEvent | GridResizeEvent > = (\n    i: string,\n    w: number,\n    h: number,\n    Data\n) => void;\n\ntype State = {\n    resizing: ? {\n        width: number,\n        height: number\n    },\n    dragging: ? {\n        top: number,\n        left: number\n    },\n    className: string\n};\n\ntype Props = {\n    children: ReactElement < any > ,\n    cols: number,\n    containerWidth: number,\n    margin: [number, number],\n    containerPadding: [number, number],\n    rowHeight: number,\n    maxRows: number,\n    isDraggable: boolean,\n    isResizable: boolean,\n    static ? : boolean,\n    useCSSTransforms ? : boolean,\n    usePercentages ? : boolean,\n    transformScale: number,\n    droppingPosition ? : DroppingPosition,\n\n    className: string,\n    style ? : Object,\n    // Draggability\n    cancel: string,\n    handle: string,\n\n    x: number,\n    y: number,\n    w: number,\n    h: number,\n\n    minW: number,\n    maxW: number,\n    minH: number,\n    maxH: number,\n    i: string,\n\n    onDrag ? : GridItemCallback < GridDragEvent > ,\n    onDragStart ? : GridItemCallback < GridDragEvent > ,\n    onDragStop ? : GridItemCallback < GridDragEvent > ,\n    onResize ? : GridItemCallback < GridResizeEvent > ,\n    onResizeStart ? : GridItemCallback < GridResizeEvent > ,\n    onResizeStop ? : GridItemCallback < GridResizeEvent >\n};\n\n/**\n * An individual item within a ReactGridLayout.\n */\nclass GridItem extends React.Component < Props, State > {\n    static propTypes = {\n        // Children must be only a single element\n        children: PropTypes.element,\n\n        // General grid attributes\n        cols: PropTypes.number.isRequired,\n        containerWidth: PropTypes.number.isRequired,\n        rowHeight: PropTypes.number.isRequired,\n        margin: PropTypes.array.isRequired,\n        maxRows: PropTypes.number.isRequired,\n        containerPadding: PropTypes.array.isRequired,\n\n        // These are all in grid units\n        x: PropTypes.number.isRequired,\n        y: PropTypes.number.isRequired,\n        w: PropTypes.number.isRequired,\n        h: PropTypes.number.isRequired,\n\n        // All optional\n        minW: function(props: Props, propName: string) {\n            const value = props[propName];\n            if (typeof value !== \"number\") return new Error(\"minWidth not Number\");\n            if (value > props.w || value > props.maxW)\n                return new Error(\"minWidth larger than item width/maxWidth\");\n        },\n\n        maxW: function(props: Props, propName: string) {\n            const value = props[propName];\n            if (typeof value !== \"number\") return new Error(\"maxWidth not Number\");\n            if (value < props.w || value < props.minW)\n                return new Error(\"maxWidth smaller than item width/minWidth\");\n        },\n\n        minH: function(props: Props, propName: string) {\n            const value = props[propName];\n            if (typeof value !== \"number\") return new Error(\"minHeight not Number\");\n            if (value > props.h || value > props.maxH)\n                return new Error(\"minHeight larger than item height/maxHeight\");\n        },\n\n        maxH: function(props: Props, propName: string) {\n            const value = props[propName];\n            if (typeof value !== \"number\") return new Error(\"maxHeight not Number\");\n            if (value < props.h || value < props.minH)\n                return new Error(\"maxHeight smaller than item height/minHeight\");\n        },\n\n        // ID is nice to have for callbacks\n        i: PropTypes.string.isRequired,\n\n        // Functions\n        onDragStop: PropTypes.func,\n        onDragStart: PropTypes.func,\n        onDrag: PropTypes.func,\n        onResizeStop: PropTypes.func,\n        onResizeStart: PropTypes.func,\n        onResize: PropTypes.func,\n\n        // Flags\n        isDraggable: PropTypes.bool.isRequired,\n        isResizable: PropTypes.bool.isRequired,\n        static: PropTypes.bool,\n\n        // Use CSS transforms instead of top/left\n        useCSSTransforms: PropTypes.bool.isRequired,\n        transformScale: PropTypes.number,\n\n        // Others\n        className: PropTypes.string,\n        // Selector for draggable handle\n        handle: PropTypes.string,\n        // Selector for draggable cancel (see react-draggable)\n        cancel: PropTypes.string,\n        // Current position of a dropping element\n        droppingPosition: PropTypes.shape({\n            x: PropTypes.number.isRequired,\n            y: PropTypes.number.isRequired\n        })\n    };\n\n    static defaultProps = {\n        className: \"\",\n        cancel: \"\",\n        handle: \"\",\n        minH: 1,\n        minW: 1,\n        maxH: Infinity,\n        maxW: Infinity,\n        transformScale: 1\n    };\n\n    state: State = {\n        resizing: null,\n        dragging: null,\n        className: \"\",\n        is_dragging: false\n    };\n\n    currentNode: HTMLElement;\n\n    componentDidUpdate(prevProps: Props) {\n        if (this.props.droppingPosition && prevProps.droppingPosition) {\n            this.moveDroppingItem(prevProps);\n        }\n    }\n\n    moveDroppingItem(prevProps: Props) {\n        const {\n            droppingPosition\n        } = this.props;\n        const {\n            dragging\n        } = this.state;\n\n        if (!droppingPosition || !prevProps.droppingPosition) {\n            return;\n        }\n\n        if (!this.currentNode) {\n            // eslint-disable-next-line react/no-find-dom-node\n            this.currentNode = ((ReactDOM.findDOMNode(this): any): HTMLElement);\n        }\n\n        const shouldDrag =\n            (dragging && droppingPosition.x !== prevProps.droppingPosition.x) ||\n            droppingPosition.y !== prevProps.droppingPosition.y;\n\n        if (!dragging) {\n            this.onDragStart(droppingPosition.e, {\n                node: this.currentNode,\n                deltaX: droppingPosition.x,\n                deltaY: droppingPosition.y\n            });\n        } else if (shouldDrag) {\n            const deltaX = droppingPosition.x - dragging.left;\n            const deltaY = droppingPosition.y - dragging.top;\n\n            this.onDrag(droppingPosition.e, {\n                node: this.currentNode,\n                deltaX,\n                deltaY\n            });\n        }\n    }\n\n    // Helper for generating column width\n    calcColWidth(): number {\n        const {\n            margin,\n            containerPadding,\n            containerWidth,\n            cols\n        } = this.props;\n        return (\n            (containerWidth - margin[0] * (cols - 1) - containerPadding[0] * 2) / cols\n        );\n    }\n\n    /**\n     * Return position on the page given an x, y, w, h.\n     * left, top, width, height are all in pixels.\n     * @param  {Number}  x             X coordinate in grid units.\n     * @param  {Number}  y             Y coordinate in grid units.\n     * @param  {Number}  w             W coordinate in grid units.\n     * @param  {Number}  h             H coordinate in grid units.\n     * @return {Object}                Object containing coords.\n     */\n    calcPosition(\n        x: number,\n        y: number,\n        w: number,\n        h: number,\n        state: ? Object\n    ): Position {\n        const {\n            margin,\n            containerPadding,\n            rowHeight\n        } = this.props;\n        const colWidth = this.calcColWidth();\n\n        const out = {\n            left: Math.round((colWidth + margin[0]) * x + containerPadding[0]),\n            top: Math.round((rowHeight + margin[1]) * y + containerPadding[1]),\n            // 0 * Infinity === NaN, which causes problems with resize constraints;\n            // Fix this if it occurs.\n            // Note we do it here rather than later because Math.round(Infinity) causes deopt\n            width: w === Infinity ?\n                w :\n                Math.round(colWidth * w + Math.max(0, w - 1) * margin[0]),\n            height: h === Infinity ?\n                h :\n                Math.round(rowHeight * h + Math.max(0, h - 1) * margin[1])\n        };\n\n        if (state && state.resizing) {\n            out.width = Math.round(state.resizing.width);\n            out.height = Math.round(state.resizing.height);\n        }\n\n        if (state && state.dragging) {\n            out.top = Math.round(state.dragging.top);\n            out.left = Math.round(state.dragging.left);\n        }\n\n        return out;\n    }\n\n    /**\n     * Translate x and y coordinates from pixels to grid units.\n     * @param  {Number} top  Top position (relative to parent) in pixels.\n     * @param  {Number} left Left position (relative to parent) in pixels.\n     * @return {Object} x and y in grid units.\n     */\n    calcXY(top: number, left: number): {\n        x: number,\n        y: number\n    } {\n        const {\n            margin,\n            cols,\n            rowHeight,\n            w,\n            h,\n            maxRows\n        } = this.props;\n        const colWidth = this.calcColWidth();\n\n        // left = colWidth * x + margin * (x + 1)\n        // l = cx + m(x+1)\n        // l = cx + mx + m\n        // l - m = cx + mx\n        // l - m = x(c + m)\n        // (l - m) / (c + m) = x\n        // x = (left - margin) / (coldWidth + margin)\n        let x = Math.round((left - margin[0]) / (colWidth + margin[0]));\n        let y = Math.round((top - margin[1]) / (rowHeight + margin[1]));\n\n        // Capping\n        x = Math.max(Math.min(x, cols - w), 0);\n        y = Math.max(Math.min(y, maxRows - h), 0);\n\n        return {\n            x,\n            y\n        };\n    }\n\n    /**\n     * Given a height and width in pixel values, calculate grid units.\n     * @param  {Number} height Height in pixels.\n     * @param  {Number} width  Width in pixels.\n     * @return {Object} w, h as grid units.\n     */\n    calcWH({\n        height,\n        width\n    }: {\n        height: number,\n        width: number\n    }): {\n        w: number,\n        h: number\n    } {\n        const {\n            margin,\n            maxRows,\n            cols,\n            rowHeight,\n            x,\n            y\n        } = this.props;\n        const colWidth = this.calcColWidth();\n\n        // width = colWidth * w - (margin * (w - 1))\n        // ...\n        // w = (width + margin) / (colWidth + margin)\n        let w = Math.round((width + margin[0]) / (colWidth + margin[0]));\n        let h = Math.round((height + margin[1]) / (rowHeight + margin[1]));\n\n        // Capping\n        w = Math.max(Math.min(w, cols - x), 0);\n        h = Math.max(Math.min(h, maxRows - y), 0);\n        return {\n            w,\n            h\n        };\n    }\n\n    /**\n     * This is where we set the grid item's absolute placement. It gets a little tricky because we want to do it\n     * well when server rendering, and the only way to do that properly is to use percentage width/left because\n     * we don't know exactly what the browser viewport is.\n     * Unfortunately, CSS Transforms, which are great for performance, break in this instance because a percentage\n     * left is relative to the item itself, not its container! So we cannot use them on the server rendering pass.\n     *\n     * @param  {Object} pos Position object with width, height, left, top.\n     * @return {Object}     Style object.\n     */\n    createStyle(pos: Position): {\n        [key: string]: ? string\n    } {\n        const {\n            usePercentages,\n            containerWidth,\n            useCSSTransforms\n        } = this.props;\n\n        let style;\n        // CSS Transforms support (default)\n        if (useCSSTransforms) {\n            style = setTransform(pos);\n        } else {\n            // top,left (slow)\n            style = setTopLeft(pos);\n\n            // This is used for server rendering.\n            if (usePercentages) {\n                style.left = perc(pos.left / containerWidth);\n                style.width = perc(pos.width / containerWidth);\n            }\n        }\n\n        return style;\n    }\n\n    /**\n     * Mix a Draggable instance into a child.\n     * @param  {Element} child    Child element.\n     * @return {Element}          Child wrapped in Draggable.\n     */\n    mixinDraggable(child: ReactElement < any > ): ReactElement < any > {\n        return (\n            <DraggableCore\n        onStart={this.onDragStart}\n        onDrag={this.onDrag}\n        onStop={this.onDragStop}\n        handle={this.props.handle}\n        cancel={\n          \".react-resizable-handle\" +\n          (this.props.cancel ? \",\" + this.props.cancel : \"\")\n        }\n      >\n        {child}\n      </DraggableCore>\n        );\n    }\n\n    /**\n     * Mix a Resizable instance into a child.\n     * @param  {Element} child    Child element.\n     * @param  {Object} position  Position object (pixel values)\n     * @return {Element}          Child wrapped in Resizable.\n     */\n    mixinResizable(\n        child: ReactElement < any > ,\n        position: Position\n    ): ReactElement < any > {\n        const {\n            cols,\n            x,\n            minW,\n            minH,\n            maxW,\n            maxH\n        } = this.props;\n\n        // This is the max possible width - doesn't go to infinity because of the width of the window\n        const maxWidth = this.calcPosition(0, 0, cols - x, 0)\n            .width;\n\n        // Calculate min/max constraints using our min & maxes\n        const mins = this.calcPosition(0, 0, minW, minH);\n        const maxes = this.calcPosition(0, 0, maxW, maxH);\n        const minConstraints = [mins.width, mins.height];\n        const maxConstraints = [\n            Math.min(maxes.width, maxWidth),\n            Math.min(maxes.height, Infinity)\n        ];\n        return (\n            <Resizable\n        width={position.width}\n        height={position.height}\n        minConstraints={minConstraints}\n        maxConstraints={maxConstraints}\n        onResizeStop={this.onResizeStop}\n        onResizeStart={this.onResizeStart}\n        onResize={this.onResize}\n      >\n        {child}\n      </Resizable>\n        );\n    }\n\n    /**\n     * onDragStart event handler\n     * @param  {Event}  e             event data\n     * @param  {Object} callbackData  an object with node, delta and position information\n     */\n    onDragStart = (e: Event, {\n        node\n    }: ReactDraggableCallbackData) => {\n        if (!this.props.onDragStart) return;\n        this.props.dragStart();\n\n        const newPosition: PartialPosition = {\n            top: 0,\n            left: 0\n        };\n\n        // TODO: this wont work on nested parents\n        const {\n            offsetParent\n        } = node;\n        if (!offsetParent) return;\n        const parentRect = offsetParent.getBoundingClientRect();\n        const clientRect = node.getBoundingClientRect();\n        const cLeft = clientRect.left / this.props.transformScale;\n        const pLeft = parentRect.left / this.props.transformScale;\n        const cTop = clientRect.top / this.props.transformScale;\n        const pTop = parentRect.top / this.props.transformScale;\n        newPosition.left = cLeft - pLeft + offsetParent.scrollLeft;\n        newPosition.top = cTop - pTop + offsetParent.scrollTop;\n        this.setState({\n            dragging: newPosition\n        });\n\n        const {\n            x,\n            y\n        } = this.calcXY(newPosition.top, newPosition.left);\n\n        return (\n            this.props.onDragStart &&\n            this.props.onDragStart.call(this, this.props.i, x, y, {\n                e,\n                node,\n                newPosition\n            })\n        );\n    };\n\n    /**\n     * onDrag event handler\n     * @param  {Event}  e             event data\n     * @param  {Object} callbackData  an object with node, delta and position information\n     */\n    onDrag = (e: Event, {\n        node,\n        deltaX,\n        deltaY\n    }: ReactDraggableCallbackData) => {\n        if (!this.props.onDrag) return;\n\n        const newPosition: PartialPosition = {\n            top: 0,\n            left: 0\n        };\n\n        if (!this.state.dragging)\n            throw new Error(\"onDrag called before onDragStart.\");\n        newPosition.left = this.state.dragging.left + deltaX;\n        newPosition.top = this.state.dragging.top + deltaY;\n        this.setState({\n            dragging: newPosition\n        });\n\n        const {\n            x,\n            y\n        } = this.calcXY(newPosition.top, newPosition.left);\n\n        return (\n            this.props.onDrag &&\n            this.props.onDrag.call(this, this.props.i, x, y, {\n                e,\n                node,\n                newPosition\n            })\n        );\n    };\n\n    /**\n     * onDragStop event handler\n     * @param  {Event}  e             event data\n     * @param  {Object} callbackData  an object with node, delta and position information\n     */\n    onDragStop = (e: Event, {\n        node\n    }: ReactDraggableCallbackData) => {\n        if (!this.props.onDragStop) return;\n\n        this.props.dragEnd();\n\n        const newPosition: PartialPosition = {\n            top: 0,\n            left: 0\n        };\n\n        if (!this.state.dragging)\n            throw new Error(\"onDragEnd called before onDragStart.\");\n        newPosition.left = this.state.dragging.left;\n        newPosition.top = this.state.dragging.top;\n        this.setState({\n            dragging: null\n        });\n\n        const {\n            x,\n            y\n        } = this.calcXY(newPosition.top, newPosition.left);\n\n        return (\n            this.props.onDragStop &&\n            this.props.onDragStop.call(this, this.props.i, x, y, {\n                e,\n                node,\n                newPosition\n            })\n        );\n    };\n\n    /**\n     * onResizeStop event handler\n     * @param  {Event}  e             event data\n     * @param  {Object} callbackData  an object with node and size information\n     */\n    onResizeStop = (\n        e: Event,\n        callbackData: {\n            node: HTMLElement,\n            size: Position\n        }\n    ) => {\n        this.props.resizeEnd();\n        this.onResizeHandler(e, callbackData, \"onResizeStop\");\n    };\n\n    /**\n     * onResizeStart event handler\n     * @param  {Event}  e             event data\n     * @param  {Object} callbackData  an object with node and size information\n     */\n    onResizeStart = (\n        e: Event,\n        callbackData: {\n            node: HTMLElement,\n            size: Position\n        }\n    ) => {\n        this.props.resizeStart();\n        this.onResizeHandler(e, callbackData, \"onResizeStart\");\n    };\n\n    /**\n     * onResize event handler\n     * @param  {Event}  e             event data\n     * @param  {Object} callbackData  an object with node and size information\n     */\n    onResize = (\n        e: Event,\n        callbackData: {\n            node: HTMLElement,\n            size: Position\n        }\n    ) => {\n        this.onResizeHandler(e, callbackData, \"onResize\");\n    };\n\n    /**\n     * Wrapper around drag events to provide more useful data.\n     * All drag events call the function with the given handler name,\n     * with the signature (index, x, y).\n     *\n     * @param  {String} handlerName Handler name to wrap.\n     * @return {Function}           Handler function.\n     */\n    onResizeHandler(\n        e: Event, {\n            node,\n            size\n        }: {\n            node: HTMLElement,\n            size: Position\n        },\n        handlerName: string\n    ) {\n        const handler = this.props[handlerName];\n        if (!handler) return;\n        const {\n            cols,\n            x,\n            i,\n            maxW,\n            minW,\n            maxH,\n            minH\n        } = this.props;\n\n        // Get new XY\n        let {\n            w,\n            h\n        } = this.calcWH(size);\n\n        // Cap w at numCols\n        w = Math.min(w, cols - x);\n        // Ensure w is at least 1\n        w = Math.max(w, 1);\n\n        // Min/max capping\n        w = Math.max(Math.min(w, maxW), minW);\n        h = Math.max(Math.min(h, maxH), minH);\n\n        this.setState({\n            resizing: handlerName === \"onResizeStop\" ? null : size\n        });\n\n        handler.call(this, i, w, h, {\n            e,\n            node,\n            size\n        });\n    }\n\n    render(): ReactNode {\n        const {\n            x,\n            y,\n            w,\n            h,\n            isDraggable,\n            isResizable,\n            droppingPosition,\n            useCSSTransforms\n        } = this.props;\n\n        const pos = this.calcPosition(x, y, w, h, this.state);\n        const child = React.Children.only(this.props.children);\n\n        // Create the child element. We clone the existing element but modify its className and style.\n        let newChild = React.cloneElement(child, {\n            className: classNames(\n                \"react-grid-item\",\n                child.props.className,\n                this.props.className, {\n                    static: this.props.static,\n                    resizing: Boolean(this.state.resizing),\n                    \"react-draggable\": isDraggable,\n                    \"react-draggable-dragging\": Boolean(this.state.dragging),\n                    dropping: Boolean(droppingPosition),\n                    cssTransforms: useCSSTransforms\n                }\n            ),\n            // We can set the width and height on the child, but unfortunately we can't set the position.\n            style: {\n                ...this.props.style,\n                ...child.props.style,\n                ...this.createStyle(pos),\n            }\n        });\n\n        // Resizable support. This is usually on but the user can toggle it off.\n        if (isResizable) newChild = this.mixinResizable(newChild, pos);\n\n        // Draggable support. This is always on, except for with placeholders.\n        if (isDraggable) newChild = this.mixinDraggable(newChild);\n\n        return newChild;\n    }\n}\n\n/* function mapStateToProps(state){\n *     return {\n *         is_dragging : state.is_dragging\n *     };\n * } */\n\nexport default connect(null, {\n    dragStart,\n    dragEnd,\n    resizeStart,\n    resizeEnd\n})(GridItem);\n","import {\n    DRAG_START,\n    DRAG_END,\n    RESIZE_START,\n    RESIZE_END\n} from \"./actionTypes\";\n\nexport const dragStart = () => ({\n    type: DRAG_START\n    /* payload: {\n     *     is_dragging: true\n     * } */\n});\n\nexport const dragEnd = () => ({\n    type: DRAG_END\n    /* payload: {\n     *     is_dragging: false\n     * } */\n});\n\nexport const resizeStart = () => ({\n    type: RESIZE_START\n});\n\nexport const resizeEnd = () => ({\n    type: RESIZE_END\n});\n","// @flow\nimport React from \"react\";\nimport PropTypes from \"prop-types\";\nimport isEqual from \"lodash.isequal\";\nimport classNames from \"classnames\";\nimport {\n    autoBindHandlers,\n    bottom,\n    childrenEqual,\n    cloneLayoutItem,\n    compact,\n    getLayoutItem,\n    moveElement,\n    synchronizeLayoutWithChildren,\n    validateLayout,\n    getAllCollisions,\n    noop\n} from \"./utils\";\nimport GridItem from \"./GridItem\";\nimport type {\n    ChildrenArray as ReactChildrenArray,\n    Element as ReactElement\n} from \"react\";\n\n// Types\nimport type {\n    EventCallback,\n    CompactType,\n    GridResizeEvent,\n    GridDragEvent,\n    DragOverEvent,\n    Layout,\n    DroppingPosition,\n    LayoutItem\n} from \"./utils\";\n\ntype State = {\n    activeDrag: ? LayoutItem,\n    layout: Layout,\n    mounted: boolean,\n    oldDragItem: ? LayoutItem,\n    oldLayout: ? Layout,\n    oldResizeItem: ? LayoutItem,\n    droppingDOMNode: ? ReactElement < any > ,\n    droppingPosition ? : DroppingPosition,\n    // Mirrored props\n    children: ReactChildrenArray < ReactElement < any >> ,\n    compactType ? : CompactType,\n    propsLayout ? : Layout\n};\n\nexport type Props = {\n    className: string,\n    style: Object,\n    width: number,\n    autoSize: boolean,\n    cols: number,\n    draggableCancel: string,\n    draggableHandle: string,\n    verticalCompact: boolean,\n    compactType: CompactType,\n    layout: Layout,\n    margin: [number, number],\n    containerPadding: [number, number] | null,\n    rowHeight: number,\n    maxRows: number,\n    isDraggable: boolean,\n    isResizable: boolean,\n    isDroppable: boolean,\n    preventCollision: boolean,\n    useCSSTransforms: boolean,\n    transformScale: number,\n    droppingItem: $Shape < LayoutItem > ,\n\n    // Callbacks\n    onLayoutChange: Layout => void,\n    onDrag: EventCallback,\n    onDragStart: EventCallback,\n    onDragStop: EventCallback,\n    onResize: EventCallback,\n    onResizeStart: EventCallback,\n    onResizeStop: EventCallback,\n    onDrop: (itemPosition: {\n        x: number,\n        y: number,\n        w: number,\n        h: number\n    }) => void,\n    children: ReactChildrenArray < ReactElement < any >>\n};\n// End Types\n\nconst compactType = (props: Props): CompactType => {\n    const {\n        verticalCompact,\n        compactType\n    } = props || {};\n\n    return verticalCompact === false ? null : compactType;\n};\n\n/**\n * A reactive, fluid grid layout with draggable, resizable components.\n */\n\nexport default class ReactGridLayout extends React.Component < Props, State > {\n    // TODO publish internal ReactClass displayName transform\n    static displayName = \"ReactGridLayout\";\n\n    static propTypes = {\n        //\n        // Basic props\n        //\n        className: PropTypes.string,\n        style: PropTypes.object,\n\n        // This can be set explicitly. If it is not set, it will automatically\n        // be set to the container width. Note that resizes will *not* cause this to adjust.\n        // If you need that behavior, use WidthProvider.\n        width: PropTypes.number,\n\n        // If true, the container height swells and contracts to fit contents\n        autoSize: PropTypes.bool,\n        // # of cols.\n        cols: PropTypes.number,\n\n        // A selector that will not be draggable.\n        draggableCancel: PropTypes.string,\n        // A selector for the draggable handler\n        draggableHandle: PropTypes.string,\n\n        // Deprecated\n        verticalCompact: function(props: Props) {\n            if (\n                props.verticalCompact === false &&\n                process.env.NODE_ENV !== \"production\"\n            ) {\n                console.warn(\n                    // eslint-disable-line no-console\n                    \"`verticalCompact` on <ReactGridLayout> is deprecated and will be removed soon. \" +\n                    'Use `compactType`: \"horizontal\" | \"vertical\" | null.'\n                );\n            }\n        },\n        // Choose vertical or hotizontal compaction\n        compactType: PropTypes.oneOf([\"vertical\", \"horizontal\"]),\n\n        // layout is an array of object with the format:\n        // {x: Number, y: Number, w: Number, h: Number, i: String}\n        layout: function(props: Props) {\n            var layout = props.layout;\n            // I hope you're setting the data-grid property on the grid items\n            if (layout === undefined) return;\n            validateLayout(layout, \"layout\");\n        },\n\n        //\n        // Grid Dimensions\n        //\n\n        // Margin between items [x, y] in px\n        margin: PropTypes.arrayOf(PropTypes.number),\n        // Padding inside the container [x, y] in px\n        containerPadding: PropTypes.arrayOf(PropTypes.number),\n        // Rows have a static height, but you can change this based on breakpoints if you like\n        rowHeight: PropTypes.number,\n        // Default Infinity, but you can specify a max here if you like.\n        // Note that this isn't fully fleshed out and won't error if you specify a layout that\n        // extends beyond the row capacity. It will, however, not allow users to drag/resize\n        // an item past the barrier. They can push items beyond the barrier, though.\n        // Intentionally not documented for this reason.\n        maxRows: PropTypes.number,\n\n        //\n        // Flags\n        //\n        isDraggable: PropTypes.bool,\n        isResizable: PropTypes.bool,\n        // If true, grid items won't change position when being dragged over.\n        preventCollision: PropTypes.bool,\n        // Use CSS transforms instead of top/left\n        useCSSTransforms: PropTypes.bool,\n        // parent layout transform scale\n        transformScale: PropTypes.number,\n        // If true, an external element can trigger onDrop callback with a specific grid position as a parameter\n        isDroppable: PropTypes.bool,\n\n        //\n        // Callbacks\n        //\n\n        // Callback so you can save the layout. Calls after each drag & resize stops.\n        onLayoutChange: PropTypes.func,\n\n        // Calls when drag starts. Callback is of the signature (layout, oldItem, newItem, placeholder, e, ?node).\n        // All callbacks below have the same signature. 'start' and 'stop' callbacks omit the 'placeholder'.\n        onDragStart: PropTypes.func,\n        // Calls on each drag movement.\n        onDrag: PropTypes.func,\n        // Calls when drag is complete.\n        onDragStop: PropTypes.func,\n        //Calls when resize starts.\n        onResizeStart: PropTypes.func,\n        // Calls when resize movement happens.\n        onResize: PropTypes.func,\n        // Calls when resize is complete.\n        onResizeStop: PropTypes.func,\n        // Calls when some element is dropped.\n        onDrop: PropTypes.func,\n\n        //\n        // Other validations\n        //\n\n        droppingItem: PropTypes.shape({\n            i: PropTypes.string.isRequired,\n            w: PropTypes.number.isRequired,\n            h: PropTypes.number.isRequired\n        }),\n\n        // Children must not have duplicate keys.\n        children: function(props: Props, propName: string) {\n            var children = props[propName];\n\n            // Check children keys for duplicates. Throw if found.\n            var keys = {};\n            React.Children.forEach(children, function(child) {\n                if (keys[child.key]) {\n                    throw new Error(\n                        'Duplicate child key \"' +\n                        child.key +\n                        '\" found! This will cause problems in ReactGridLayout.'\n                    );\n                }\n                keys[child.key] = true;\n            });\n        }\n    };\n\n    static defaultProps = {\n        autoSize: true,\n        cols: 12,\n        className: \"\",\n        style: {},\n        draggableHandle: \"\",\n        draggableCancel: \"\",\n        containerPadding: null,\n        rowHeight: 150,\n        maxRows: Infinity, // infinite vertical growth\n        layout: [],\n        margin: [10, 10],\n        isDraggable: true,\n        isResizable: true,\n        isDroppable: false,\n        useCSSTransforms: true,\n        transformScale: 1,\n        verticalCompact: true,\n        compactType: \"vertical\",\n        preventCollision: false,\n        droppingItem: {\n            i: \"__dropping-elem__\",\n            h: 1,\n            w: 1\n        },\n        onLayoutChange: noop,\n        onDragStart: noop,\n        onDrag: noop,\n        onDragStop: noop,\n        onResizeStart: noop,\n        onResize: noop,\n        onResizeStop: noop,\n        onDrop: noop\n    };\n\n    state: State = {\n        activeDrag: null,\n        layout: synchronizeLayoutWithChildren(\n            this.props.layout,\n            this.props.children,\n            this.props.cols,\n            // Legacy support for verticalCompact: false\n            compactType(this.props)\n        ),\n        mounted: false,\n        oldDragItem: null,\n        oldLayout: null,\n        oldResizeItem: null,\n        droppingDOMNode: null,\n        children: []\n    };\n\n    constructor(props: Props, context: any): void {\n        super(props, context);\n        autoBindHandlers(this, [\n            \"onDragStart\",\n            \"onDrag\",\n            \"onDragStop\",\n            \"onResizeStart\",\n            \"onResize\",\n            \"onResizeStop\"\n        ]);\n    }\n\n    componentDidMount() {\n        this.setState({\n            mounted: true\n        });\n        // Possibly call back with layout on mount. This should be done after correcting the layout width\n        // to ensure we don't rerender with the wrong width.\n        this.onLayoutMaybeChanged(this.state.layout, this.props.layout);\n    }\n\n    static getDerivedStateFromProps(nextProps: Props, prevState: State) {\n        let newLayoutBase;\n\n        if (prevState.activeDrag) {\n            return null;\n        }\n\n        // Legacy support for compactType\n        // Allow parent to set layout directly.\n        if (\n            !isEqual(nextProps.layout, prevState.propsLayout) ||\n            nextProps.compactType !== prevState.compactType\n        ) {\n            newLayoutBase = nextProps.layout;\n        } else if (!childrenEqual(nextProps.children, prevState.children)) {\n            // If children change, also regenerate the layout. Use our state\n            // as the base in case because it may be more up to date than\n            // what is in props.\n            newLayoutBase = prevState.layout;\n        }\n\n        // We need to regenerate the layout.\n        if (newLayoutBase) {\n            const newLayout = synchronizeLayoutWithChildren(\n                newLayoutBase,\n                nextProps.children,\n                nextProps.cols,\n                compactType(nextProps)\n            );\n\n            return {\n                layout: newLayout,\n                // We need to save these props to state for using\n                // getDerivedStateFromProps instead of componentDidMount (in which we would get extra rerender)\n                compactType: nextProps.compactType,\n                children: nextProps.children,\n                propsLayout: nextProps.layout\n            };\n        }\n\n        return null;\n    }\n\n    componentDidUpdate(prevProps: Props, prevState: State) {\n        if (!this.state.activeDrag) {\n            const newLayout = this.state.layout;\n            const oldLayout = prevState.layout;\n\n            this.onLayoutMaybeChanged(newLayout, oldLayout);\n        }\n    }\n\n    /**\n     * Calculates a pixel value for the container.\n     * @return {String} Container height in pixels.\n     */\n    containerHeight() {\n        if (!this.props.autoSize) return;\n        const nbRow = bottom(this.state.layout);\n        const containerPaddingY = this.props.containerPadding ?\n            this.props.containerPadding[1] :\n            this.props.margin[1];\n        return (\n            nbRow * this.props.rowHeight +\n            (nbRow - 1) * this.props.margin[1] +\n            containerPaddingY * 2 +\n            \"px\"\n        );\n    }\n\n    /**\n     * When dragging starts\n     * @param {String} i Id of the child\n     * @param {Number} x X position of the move\n     * @param {Number} y Y position of the move\n     * @param {Event} e The mousedown event\n     * @param {Element} node The current dragging DOM element\n     */\n    onDragStart(i: string, x: number, y: number, {\n        e,\n        node\n    }: GridDragEvent) {\n        const {\n            layout\n        } = this.state;\n        var l = getLayoutItem(layout, i);\n        if (!l) return;\n\n        this.setState({\n            oldDragItem: cloneLayoutItem(l),\n            oldLayout: this.state.layout\n        });\n\n        return this.props.onDragStart(layout, l, l, null, e, node);\n    }\n\n    /**\n     * Each drag movement create a new dragelement and move the element to the dragged location\n     * @param {String} i Id of the child\n     * @param {Number} x X position of the move\n     * @param {Number} y Y position of the move\n     * @param {Event} e The mousedown event\n     * @param {Element} node The current dragging DOM element\n     */\n    onDrag(i: string, x: number, y: number, {\n        e,\n        node\n    }: GridDragEvent) {\n        const {\n            oldDragItem\n        } = this.state;\n        let {\n            layout\n        } = this.state;\n        const {\n            cols\n        } = this.props;\n        var l = getLayoutItem(layout, i);\n        if (!l) return;\n\n        // Create placeholder (display only)\n        var placeholder = {\n            w: l.w,\n            h: l.h,\n            x: l.x,\n            y: l.y,\n            placeholder: true,\n            i: i\n        };\n\n        // Move the element to the dragged location.\n        const isUserAction = true;\n        layout = moveElement(\n            layout,\n            l,\n            x,\n            y,\n            isUserAction,\n            this.props.preventCollision,\n            compactType(this.props),\n            cols\n        );\n\n        this.props.onDrag(layout, oldDragItem, l, placeholder, e, node);\n\n        this.setState({\n            layout: compact(layout, compactType(this.props), cols),\n            activeDrag: placeholder\n        });\n    }\n\n    /**\n     * When dragging stops, figure out which position the element is closest to and update its x and y.\n     * @param  {String} i Index of the child.\n     * @param {Number} x X position of the move\n     * @param {Number} y Y position of the move\n     * @param {Event} e The mousedown event\n     * @param {Element} node The current dragging DOM element\n     */\n    onDragStop(i: string, x: number, y: number, {\n        e,\n        node\n    }: GridDragEvent) {\n        const {\n            oldDragItem\n        } = this.state;\n        let {\n            layout\n        } = this.state;\n        const {\n            cols,\n            preventCollision\n        } = this.props;\n        const l = getLayoutItem(layout, i);\n        if (!l) return;\n\n        // Move the element here\n        const isUserAction = true;\n        layout = moveElement(\n            layout,\n            l,\n            x,\n            y,\n            isUserAction,\n            preventCollision,\n            compactType(this.props),\n            cols\n        );\n\n        this.props.onDragStop(layout, oldDragItem, l, null, e, node);\n\n        // Set state\n        const newLayout = compact(layout, compactType(this.props), cols);\n        const {\n            oldLayout\n        } = this.state;\n        this.setState({\n            activeDrag: null,\n            layout: newLayout,\n            oldDragItem: null,\n            oldLayout: null\n        });\n\n        this.onLayoutMaybeChanged(newLayout, oldLayout);\n    }\n\n    onLayoutMaybeChanged(newLayout: Layout, oldLayout: ? Layout) {\n        if (!oldLayout) oldLayout = this.state.layout;\n\n        if (!isEqual(oldLayout, newLayout)) {\n            this.props.onLayoutChange(newLayout);\n        }\n    }\n\n    onResizeStart(i: string, w: number, h: number, {\n        e,\n        node\n    }: GridResizeEvent) {\n        const {\n            layout\n        } = this.state;\n        var l = getLayoutItem(layout, i);\n        if (!l) return;\n\n        this.setState({\n            oldResizeItem: cloneLayoutItem(l),\n            oldLayout: this.state.layout\n        });\n\n        this.props.onResizeStart(layout, l, l, null, e, node);\n    }\n\n    onResize(i: string, w: number, h: number, {\n        e,\n        node\n    }: GridResizeEvent) {\n        const {\n            layout,\n            oldResizeItem\n        } = this.state;\n        const {\n            cols,\n            preventCollision\n        } = this.props;\n        const l: ? LayoutItem = getLayoutItem(layout, i);\n        if (!l) return;\n\n        // Something like quad tree should be used\n        // to find collisions faster\n        let hasCollisions;\n        if (preventCollision) {\n            const collisions = getAllCollisions(layout, {\n                    ...l,\n                    w,\n                    h\n                })\n                .filter(\n                    layoutItem => layoutItem.i !== l.i\n                );\n            hasCollisions = collisions.length > 0;\n\n            // If we're colliding, we need adjust the placeholder.\n            if (hasCollisions) {\n                // adjust w && h to maximum allowed space\n                let leastX = Infinity,\n                    leastY = Infinity;\n                collisions.forEach(layoutItem => {\n                    if (layoutItem.x > l.x) leastX = Math.min(leastX, layoutItem.x);\n                    if (layoutItem.y > l.y) leastY = Math.min(leastY, layoutItem.y);\n                });\n\n                if (Number.isFinite(leastX)) l.w = leastX - l.x;\n                if (Number.isFinite(leastY)) l.h = leastY - l.y;\n            }\n        }\n\n        if (!hasCollisions) {\n            // Set new width and height.\n            l.w = w;\n            l.h = h;\n        }\n\n        // Create placeholder element (display only)\n        var placeholder = {\n            w: l.w,\n            h: l.h,\n            x: l.x,\n            y: l.y,\n            static: true,\n            i: i\n        };\n\n        this.props.onResize(layout, oldResizeItem, l, placeholder, e, node);\n\n        // Re-compact the layout and set the drag placeholder.\n        this.setState({\n            layout: compact(layout, compactType(this.props), cols),\n            activeDrag: placeholder\n        });\n    }\n\n    onResizeStop(i: string, w: number, h: number, {\n        e,\n        node\n    }: GridResizeEvent) {\n        const {\n            layout,\n            oldResizeItem\n        } = this.state;\n        const {\n            cols\n        } = this.props;\n        var l = getLayoutItem(layout, i);\n\n        this.props.onResizeStop(layout, oldResizeItem, l, null, e, node);\n\n        // Set state\n        const newLayout = compact(layout, compactType(this.props), cols);\n        const {\n            oldLayout\n        } = this.state;\n        this.setState({\n            activeDrag: null,\n            layout: newLayout,\n            oldResizeItem: null,\n            oldLayout: null\n        });\n\n        this.onLayoutMaybeChanged(newLayout, oldLayout);\n    }\n\n    /**\n     * Create a placeholder object.\n     * @return {Element} Placeholder div.\n     */\n    placeholder(): ? ReactElement < any > {\n        const {\n            activeDrag\n        } = this.state;\n        if (!activeDrag) return null;\n        const {\n            width,\n            cols,\n            margin,\n            containerPadding,\n            rowHeight,\n            maxRows,\n            useCSSTransforms,\n            transformScale\n        } = this.props;\n\n        // {...this.state.activeDrag} is pretty slow, actually\n        return (\n            <GridItem\n        w={activeDrag.w}\n        h={activeDrag.h}\n        x={activeDrag.x}\n        y={activeDrag.y}\n        i={activeDrag.i}\n        className=\"react-grid-placeholder\"\n        containerWidth={width}\n        cols={cols}\n        margin={margin}\n        containerPadding={containerPadding || margin}\n        maxRows={maxRows}\n        rowHeight={rowHeight}\n        isDraggable={false}\n        isResizable={false}\n        useCSSTransforms={useCSSTransforms}\n        transformScale={transformScale}\n      >\n        <div />\n      </GridItem>\n        );\n    }\n\n    /**\n     * Given a grid item, set its style attributes & surround in a <Draggable>.\n     * @param  {Element} child React element.\n     * @return {Element}       Element wrapped in draggable and properly placed.\n     */\n    processGridItem(\n        child: ReactElement < any > ,\n        isDroppingItem ? : boolean\n    ): ? ReactElement < any > {\n        if (!child || !child.key) return;\n        const l = getLayoutItem(this.state.layout, String(child.key));\n        if (!l) return null;\n        const {\n            width,\n            cols,\n            margin,\n            containerPadding,\n            rowHeight,\n            maxRows,\n            isDraggable,\n            isResizable,\n            useCSSTransforms,\n            transformScale,\n            draggableCancel,\n            draggableHandle\n        } = this.props;\n        const {\n            mounted,\n            droppingPosition\n        } = this.state;\n\n        // Parse 'static'. Any properties defined directly on the grid item will take precedence.\n        const draggable = Boolean(\n            !l.static && isDraggable && (l.isDraggable || l.isDraggable == null)\n        );\n        const resizable = Boolean(\n            !l.static && isResizable && (l.isResizable || l.isResizable == null)\n        );\n\n        return (\n            <GridItem\n        containerWidth={width}\n        cols={cols}\n        margin={margin}\n        containerPadding={containerPadding || margin}\n        maxRows={maxRows}\n        rowHeight={rowHeight}\n        cancel={draggableCancel}\n        handle={draggableHandle}\n        onDragStop={this.onDragStop}\n        onDragStart={this.onDragStart}\n        onDrag={this.onDrag}\n        onResizeStart={this.onResizeStart}\n        onResize={this.onResize}\n        onResizeStop={this.onResizeStop}\n        isDraggable={draggable}\n        isResizable={resizable}\n        useCSSTransforms={useCSSTransforms && mounted}\n        usePercentages={!mounted}\n        transformScale={transformScale}\n        w={l.w}\n        h={l.h}\n        x={l.x}\n        y={l.y}\n        i={l.i}\n        minH={l.minH}\n        minW={l.minW}\n        maxH={l.maxH}\n        maxW={l.maxW}\n        static={l.static}\n        droppingPosition={isDroppingItem ? droppingPosition : undefined}\n      >\n        {child}\n      </GridItem>\n        );\n    }\n\n    onDragOver = (e: DragOverEvent) => {\n        const {\n            droppingItem\n        } = this.props;\n        const {\n            layout\n        } = this.state;\n        const {\n            layerX,\n            layerY\n        } = e.nativeEvent;\n        const droppingPosition = {\n            x: layerX,\n            y: layerY,\n            e\n        };\n\n        if (!this.state.droppingDOMNode) {\n            this.setState({\n                droppingDOMNode: <div key={droppingItem.i} />,\n                droppingPosition,\n                layout: [\n                    ...layout,\n                    {\n                        ...droppingItem,\n                        x: 0,\n                        y: 0,\n                        static: false,\n                        isDraggable: true\n                    }\n                ]\n            });\n        } else if (this.state.droppingPosition) {\n            const shouldUpdatePosition =\n                this.state.droppingPosition.x != layerX ||\n                this.state.droppingPosition.y != layerY;\n            shouldUpdatePosition && this.setState({\n                droppingPosition\n            });\n        }\n\n        e.stopPropagation();\n        e.preventDefault();\n    };\n\n    onDrop = () => {\n        const {\n            droppingItem,\n            cols\n        } = this.props;\n        const {\n            layout\n        } = this.state;\n\n        const {\n            x,\n            y,\n            w,\n            h\n        } = layout.find(l => l.i === droppingItem.i) || {};\n        const newLayout = compact(\n            layout.filter(l => l.i !== droppingItem.i),\n            compactType(this.props),\n            cols\n        );\n\n        this.setState({\n            layout: newLayout,\n            droppingDOMNode: null,\n            activeDrag: null,\n            droppingPosition: undefined\n        });\n\n        this.props.onDrop({\n            x,\n            y,\n            w,\n            h\n        });\n    };\n\n    render() {\n        const {\n            className,\n            style,\n            isDroppable\n        } = this.props;\n\n        const mergedClassName = classNames(\"react-grid-layout\", className);\n        const mergedStyle = {\n            height: this.containerHeight(),\n            ...style\n        };\n\n        return (\n            <div\n        className={mergedClassName}\n        style={mergedStyle}\n        onDrop={isDroppable ? this.onDrop : noop}\n        onDragOver={isDroppable ? this.onDragOver : noop}\n      >\n        {React.Children.map(this.props.children, child =>\n          this.processGridItem(child)\n        )}\n        {isDroppable &&\n          this.state.droppingDOMNode &&\n          this.processGridItem(this.state.droppingDOMNode, true)}\n        {this.placeholder()}\n      </div>\n        );\n    }\n}\n","// @flow\nimport React from \"react\";\nimport PropTypes from \"prop-types\";\nimport isEqual from \"lodash.isequal\";\n\nimport {\n  cloneLayout,\n  synchronizeLayoutWithChildren,\n  validateLayout,\n  noop\n} from \"./utils\";\nimport {\n  getBreakpointFromWidth,\n  getColsFromBreakpoint,\n  findOrGenerateResponsiveLayout\n} from \"./responsiveUtils\";\nimport ReactGridLayout from \"./ReactGridLayout\";\nimport type { Props as RGLProps } from \"./ReactGridLayout\";\nimport type { Layout } from \"./utils\";\n\nconst type = obj => Object.prototype.toString.call(obj);\n\ntype State = {\n  layout: Layout,\n  breakpoint: string,\n  cols: number,\n  layouts?: { [key: string]: Layout }\n};\n\ntype Props<Breakpoint: string = string> = {\n  ...$Exact<RGLProps>,\n\n  // Responsive config\n  breakpoint: Breakpoint,\n  breakpoints: { [key: Breakpoint]: number },\n  cols: { [key: Breakpoint]: number },\n  layouts: { [key: Breakpoint]: Layout },\n  width: number,\n\n  // Callbacks\n  onBreakpointChange: (Breakpoint, cols: number) => void,\n  onLayoutChange: (Layout, { [key: Breakpoint]: Layout }) => void,\n  onWidthChange: (\n    containerWidth: number,\n    margin: [number, number],\n    cols: number,\n    containerPadding: [number, number] | null\n  ) => void\n};\n\nexport default class ResponsiveReactGridLayout extends React.Component<\n  Props<>,\n  State\n> {\n  // This should only include propTypes needed in this code; RGL itself\n  // will do validation of the rest props passed to it.\n  static propTypes = {\n    //\n    // Basic props\n    //\n\n    // Optional, but if you are managing width yourself you may want to set the breakpoint\n    // yourself as well.\n    breakpoint: PropTypes.string,\n\n    // {name: pxVal}, e.g. {lg: 1200, md: 996, sm: 768, xs: 480}\n    breakpoints: PropTypes.object,\n\n    // # of cols. This is a breakpoint -> cols map\n    cols: PropTypes.object,\n\n    // layouts is an object mapping breakpoints to layouts.\n    // e.g. {lg: Layout, md: Layout, ...}\n    layouts(props: Props<>, propName: string) {\n      if (type(props[propName]) !== \"[object Object]\") {\n        throw new Error(\n          \"Layout property must be an object. Received: \" +\n            type(props[propName])\n        );\n      }\n      Object.keys(props[propName]).forEach(key => {\n        if (!(key in props.breakpoints)) {\n          throw new Error(\n            \"Each key in layouts must align with a key in breakpoints.\"\n          );\n        }\n        validateLayout(props.layouts[key], \"layouts.\" + key);\n      });\n    },\n\n    // The width of this component.\n    // Required in this propTypes stanza because generateInitialState() will fail without it.\n    width: PropTypes.number.isRequired,\n\n    //\n    // Callbacks\n    //\n\n    // Calls back with breakpoint and new # cols\n    onBreakpointChange: PropTypes.func,\n\n    // Callback so you can save the layout.\n    // Calls back with (currentLayout, allLayouts). allLayouts are keyed by breakpoint.\n    onLayoutChange: PropTypes.func,\n\n    // Calls back with (containerWidth, margin, cols, containerPadding)\n    onWidthChange: PropTypes.func\n  };\n\n  static defaultProps = {\n    breakpoints: { lg: 1200, md: 996, sm: 768, xs: 480, xxs: 0 },\n    cols: { lg: 12, md: 10, sm: 6, xs: 4, xxs: 2 },\n    layouts: {},\n    onBreakpointChange: noop,\n    onLayoutChange: noop,\n    onWidthChange: noop\n  };\n\n  state = this.generateInitialState();\n\n  generateInitialState(): State {\n    const { width, breakpoints, layouts, cols } = this.props;\n    const breakpoint = getBreakpointFromWidth(breakpoints, width);\n    const colNo = getColsFromBreakpoint(breakpoint, cols);\n    // verticalCompact compatibility, now deprecated\n    const compactType =\n      this.props.verticalCompact === false ? null : this.props.compactType;\n    // Get the initial layout. This can tricky; we try to generate one however possible if one doesn't exist\n    // for this layout.\n    const initialLayout = findOrGenerateResponsiveLayout(\n      layouts,\n      breakpoints,\n      breakpoint,\n      breakpoint,\n      colNo,\n      compactType\n    );\n\n    return {\n      layout: initialLayout,\n      breakpoint: breakpoint,\n      cols: colNo\n    };\n  }\n\n  static getDerivedStateFromProps(nextProps: Props<*>, prevState: State) {\n    if (!isEqual(nextProps.layouts, prevState.layouts)) {\n      // Allow parent to set layouts directly.\n      const { breakpoint, cols } = prevState;\n\n      // Since we're setting an entirely new layout object, we must generate a new responsive layout\n      // if one does not exist.\n      const newLayout = findOrGenerateResponsiveLayout(\n        nextProps.layouts,\n        nextProps.breakpoints,\n        breakpoint,\n        breakpoint,\n        cols,\n        nextProps.compactType\n      );\n      return { layout: newLayout, layouts: nextProps.layouts };\n    }\n\n    return null;\n  }\n\n  componentDidUpdate(prevProps: Props<*>) {\n    // Allow parent to set width or breakpoint directly.\n    if (\n      this.props.width != prevProps.width ||\n      this.props.breakpoint !== prevProps.breakpoint ||\n      !isEqual(this.props.breakpoints, prevProps.breakpoints) ||\n      !isEqual(this.props.cols, prevProps.cols)\n    ) {\n      this.onWidthChange(this.props);\n    }\n  }\n\n  // wrap layouts so we do not need to pass layouts to child\n  onLayoutChange = (layout: Layout) => {\n    this.props.onLayoutChange(layout, {\n      ...this.props.layouts,\n      [this.state.breakpoint]: layout\n    });\n  };\n\n  /**\n   * When the width changes work through breakpoints and reset state with the new width & breakpoint.\n   * Width changes are necessary to figure out the widget widths.\n   */\n  onWidthChange(nextProps: Props<*>) {\n    const { breakpoints, cols, layouts, compactType } = nextProps;\n    const newBreakpoint =\n      nextProps.breakpoint ||\n      getBreakpointFromWidth(nextProps.breakpoints, nextProps.width);\n\n    const lastBreakpoint = this.state.breakpoint;\n    const newCols: number = getColsFromBreakpoint(newBreakpoint, cols);\n\n    // Breakpoint change\n    if (\n      lastBreakpoint !== newBreakpoint ||\n      this.props.breakpoints !== breakpoints ||\n      this.props.cols !== cols\n    ) {\n      // Preserve the current layout if the current breakpoint is not present in the next layouts.\n      if (!(lastBreakpoint in layouts))\n        layouts[lastBreakpoint] = cloneLayout(this.state.layout);\n\n      // Find or generate a new layout.\n      let layout = findOrGenerateResponsiveLayout(\n        layouts,\n        breakpoints,\n        newBreakpoint,\n        lastBreakpoint,\n        newCols,\n        compactType\n      );\n\n      // This adds missing items.\n      layout = synchronizeLayoutWithChildren(\n        layout,\n        nextProps.children,\n        newCols,\n        compactType\n      );\n\n      // Store the new layout.\n      layouts[newBreakpoint] = layout;\n\n      // callbacks\n      this.props.onLayoutChange(layout, layouts);\n      this.props.onBreakpointChange(newBreakpoint, newCols);\n\n      this.setState({\n        breakpoint: newBreakpoint,\n        layout: layout,\n        cols: newCols\n      });\n    }\n    //call onWidthChange on every change of width, not only on breakpoint changes\n    this.props.onWidthChange(\n      nextProps.width,\n      nextProps.margin,\n      newCols,\n      nextProps.containerPadding\n    );\n  }\n\n  render() {\n    /* eslint-disable no-unused-vars */\n    const {\n      breakpoint,\n      breakpoints,\n      cols,\n      layouts,\n      onBreakpointChange,\n      onLayoutChange,\n      onWidthChange,\n      ...other\n    } = this.props;\n    /* eslint-enable no-unused-vars */\n\n    return (\n      <ReactGridLayout\n        {...other}\n        onLayoutChange={this.onLayoutChange}\n        layout={this.state.layout}\n        cols={this.state.cols}\n      />\n    );\n  }\n}\n","/* import React from \"react\"; */\nimport ResponsiveReactGridLayout from '../react-grid-layout/ResponsiveReactGridLayout';\n\nimport '../react-grid-layout/styles.css'\nexport class IframeGridLayout extends ResponsiveReactGridLayout {\n    constructor(props){\n        console.log('IframeGridLayout created');\n        super(props);\n    }\n\n    onDragStart(i, x, y, _ref) {\n        console.log('Start');\n        return super.onDragStart(i, x, y, _ref);\n    }\n}\n\nexport default IframeGridLayout;\n","import { DRAG_START, DRAG_END, RESIZE_START, RESIZE_END } from \"../actionTypes\";\n\nconst initialState = {\n    is_dragging: false,\n    is_resizing: false\n};\n\nfunction rootReducer(state = initialState, action){\n    console.log('reducer', action);\n    switch(action.type) {\n        case DRAG_START:\n            return {\n                is_dragging: true,\n                is_resizing: false\n            };\n        case DRAG_END: {\n            return {\n                is_dragging: false,\n                is_resizing: false\n            };\n        }\n        case RESIZE_START: {\n            return {\n                is_dragging: false,\n                is_resizing: true\n            };\n        }\n        case RESIZE_END: {\n            return {\n                is_dragging: false,\n                is_resizing: false,\n            }\n        }\n        default:\n            return state;\n    }\n};\n\nexport default rootReducer;\n","import { createStore } from \"redux\";\nimport rootReducer from \"./reducers/index\";\n\nexport default createStore(rootReducer);\n","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.1/8 is considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\nexport function register(config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(process.env.PUBLIC_URL, window.location.href);\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl, config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch(error => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl, config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl)\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready.then(registration => {\n      registration.unregister();\n    });\n  }\n}\n","import React from 'react';\nimport ReactDOM from 'react-dom';\n\nimport {\n    Provider\n} from 'react-redux';\nimport store from './redux/store'\n\nimport * as serviceWorker from './serviceWorker';\n\nimport './index.css';\nimport App from './App';\n\nstore.dispatch({type: \"DRAG_START\"});\n\nReactDOM.render(\n    <Provider store={store}>\n        <App />\n    </Provider>,\n    document.getElementById('root')\n);\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: https://bit.ly/CRA-PWA\nserviceWorker.unregister();\n"],"sourceRoot":""}