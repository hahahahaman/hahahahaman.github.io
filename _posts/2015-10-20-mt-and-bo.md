---
layout: post
title: Breakout and Matrix Transforms
---

## Playing around with OpenGL

I've been working through parts of this [tutorial](http://learnopengl.com) for
some time, converting the C++ into Common Lisp. OpenGL is pretty annoying just
because it's kind of low level and thus you have to be specific about what you
want it to do; I spent some days looking for one or two omissions in my code, which
was the difference between what I expected and a blank screen. The author writes
straightforward tutorials, that outline the concepts pretty well, but I've noticed
while following them that there is something about the stylistic approach which
drives me to write it another way. It could be the translation between C++ and
Common Lisp, but actually the cl-opengl mappings allow for basically
the same approach to writing the code. I think it has to do with the fact that
since I'm taking a more _active_ means of following the tutorial by basically
rewriting the code, I don't copy and paste core parts that I want working and
instead try to write something that I think _feels_ better in my head, and I
think reading more lisp code has affected my preferences.

It's been several months since I first touched OpenGL and in that time I've
changed the way I look at abstractions. I'm trying more and more to give up
classes and structs, replacing them with data structures, like associative
arrays (aka hashtables/dictionaries/maps, things along those lines). Using raw
data structures in prototypes helps with bottom up programming, since classes
imply a pattern; they are clunky to start off with, because of the added
verbosity of new methods and slots and are prone to change; it's much easier
just to added something to a hash-table and then look it up.

## More interactive programming

Something I really like about Common Lisp, SLIME, and Emacs (I'm using
[Spacemacs](https://github.com/syl20bnr/spacemacs)), is the contrast in the
interactivity of the programming it, in comparison to stuff I used before like
C++, Java.... Actually I was pretty impressed by how nice web development is in
terms of seeing changes as they are made. When I was making this site I used the
Firefox web development thing, that allowed me to test out color schemes and
layouts, and I installed a plugin that refreshes my page whenever I save my
file. I've also seen thing like react.js, which I don't really know much about,
but I can see that it changes the application as the code changes.

I was really inspired by Bret Victors videos, especially
[Inventing on Principle](https://vimeo.com/36579366), which in turn inspired a
lot of stuff, notably the editor for [Frogatto & Friends](http://www.frogatto.com/).

In the few months I was working on the breakout clone, the game itself was
not that important, and looking back, that decision seems somewhat like a
mistake, since I got rather disappointing results in terms of the game, but it's
simplicity and familiarity were helpful in doing more complicated things that
did interest me. At the time I was fascinated with time-traveling debugging and
entity component systems, both of which I've incorporated and played around with
during the making of bo.

They allow me to more flexibly program games, since I can keep the game running
constantly, while I add changes, because of Common Lisp incremental compilation,
and I can rewind the game itself to look at the results of the new behavior and
track down bugs and such. SBCL has a nice inspector I can use to look at objects
at run time, and I can use the RE PL to call functions. It's really quite an
improvement from the way I programmed C++, which was basically changing large
portions of code, keeping track of where the changes were, and then debugging it
until it compiled properly.

I'm still kind of concerned about the nature of programming using written
symbolic language, can't help but feel like it's low bandwidth, in terms of
human-to-human knowledge transfer, but not sure how to tackle such a problem.

## Prototyping matrix transforms

Inspired by hexcells infinite, I had the concept of a simple puzzle game that
had non-trivial problems that could increase in complexity pretty easily. The
game is really quite stupid in terms of intellectual value, since the
problem is rather simple, but is convoluted by the presentation.

## Sharing is difficult

I wonder if God looked at his creation and realized that it was worthless and
deformed, then left it to rot. I wonder because I feel mt is not worth
touching anymore. It's difficult to let it go, though. I thought it was kind of
fun, but I can see that my sentiments are not really shared. It would be vain of
me to say that only my opinion matters, but I don't think it's reasonable to say
that the game was failure just because no really cares about it. 

I guess I still have a long time till I pay my dues.
